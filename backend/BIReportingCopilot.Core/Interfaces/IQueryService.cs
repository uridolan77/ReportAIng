using BIReportingCopilot.Core.Models;
using BIReportingCopilot.Core.Models.DTOs;
using BIReportingCopilot.Core.DTOs.SchemaManagement;
using CoreModels = BIReportingCopilot.Core.Models;

namespace BIReportingCopilot.Core.Interfaces;

/// <summary>
/// Unified query service interface combining standard and advanced query processing
/// </summary>
public interface IQueryService
{
    // Standard query processing
    Task<QueryResponse> ProcessQueryAsync(QueryRequest request, string userId);
    Task<QueryResponse> ProcessQueryAsync(QueryRequest request, string userId, CancellationToken cancellationToken);
    Task<List<QueryHistoryItem>> GetQueryHistoryAsync(string userId, int page = 1, int pageSize = 20);
    Task<bool> SubmitFeedbackAsync(QueryFeedback feedback, string userId);
    Task<List<string>> GetQuerySuggestionsAsync(string userId, string? context = null);
    Task<QueryResponse?> GetCachedQueryAsync(string queryHash);
    Task CacheQueryAsync(string queryHash, QueryResponse response, TimeSpan? expiry = null);
    Task InvalidateQueryCacheAsync(string pattern);

    // Advanced query processing capabilities
    Task<ProcessedQuery> ProcessAdvancedQueryAsync(string query, string userId, CoreModels.QueryContext? context = null);
    Task<double> CalculateSemanticSimilarityAsync(string query1, string query2);
    Task<List<ProcessedQuery>> FindSimilarQueriesAsync(string query, string userId, int limit = 5);

    // Performance and optimization methods
    Task<QueryPerformanceMetrics> GetQueryPerformanceAsync(string queryHash);
    Task<bool> ValidateQueryAsync(string sql);
    Task<List<QuerySuggestion>> GetSmartSuggestionsAsync(string userId, string? context = null);
    Task<QueryOptimizationResult> OptimizeQueryAsync(string sql);
}

/// <summary>
/// Unified AI service interface combining standard and streaming capabilities
/// </summary>
public interface IAIService
{
    // Standard AI operations
    Task<string> GenerateSQLAsync(string prompt);
    Task<string> GenerateSQLAsync(string prompt, CancellationToken cancellationToken);
    Task<string> GenerateInsightAsync(string query, object[] data);
    Task<string> GenerateVisualizationConfigAsync(string query, ColumnMetadata[] columns, object[] data);
    Task<double> CalculateConfidenceScoreAsync(string naturalLanguageQuery, string generatedSQL);
    Task<string[]> GenerateQuerySuggestionsAsync(string context, SchemaMetadata schema);
    Task<bool> ValidateQueryIntentAsync(string naturalLanguageQuery);

    // Streaming capabilities
    IAsyncEnumerable<StreamingResponse> GenerateSQLStreamAsync(string prompt, SchemaMetadata? schema = null, CoreModels.QueryContext? context = null, CancellationToken cancellationToken = default);
    IAsyncEnumerable<StreamingResponse> GenerateInsightStreamAsync(string query, object[] data, CoreModels.AnalysisContext? context = null, CancellationToken cancellationToken = default);
    IAsyncEnumerable<StreamingResponse> GenerateExplanationStreamAsync(string sql, CoreModels.StreamingQueryComplexity complexity = CoreModels.StreamingQueryComplexity.Medium, CancellationToken cancellationToken = default);
}

// AI Provider abstraction interfaces
public interface IAIProvider
{
    Task<string> GenerateCompletionAsync(string prompt, AIOptions options);
    Task<string> GenerateCompletionAsync(string prompt, AIOptions options, CancellationToken cancellationToken);
    IAsyncEnumerable<StreamingResponse> GenerateCompletionStreamAsync(string prompt, AIOptions options, CancellationToken cancellationToken = default);
    bool IsConfigured { get; }
    string ProviderName { get; }
}

public interface IAIProviderFactory
{
    IAIProvider GetProvider();
    IAIProvider GetProvider(string providerName);
    IEnumerable<string> GetAvailableProviders();
}

// New advanced AI/ML interfaces
public interface ISemanticAnalyzer
{
    Task<SemanticAnalysis> AnalyzeAsync(string naturalLanguageQuery);
    Task<float[]> GenerateEmbeddingAsync(string text);
    Task<SemanticSimilarity> CalculateSimilarityAsync(string query1, string query2);
    Task<List<SemanticEntity>> ExtractEntitiesAsync(string query);
    Task<QueryIntent> ClassifyIntentAsync(string query);
}

public interface IQueryClassifier
{
    Task<QueryClassification> ClassifyQueryAsync(string query);
    Task<QueryComplexityScore> AnalyzeComplexityAsync(string query);
    Task<List<string>> SuggestOptimizationsAsync(string query);
    Task<bool> RequiresJoinAsync(string query, SchemaMetadata schema);
}

public interface IContextManager
{
    Task<UserContext> GetUserContextAsync(string userId);
    Task UpdateUserContextAsync(string userId, QueryRequest request, QueryResponse response);
    Task<List<QueryPattern>> GetQueryPatternsAsync(string userId);
    Task<SchemaContext> GetRelevantSchemaAsync(string query, SchemaMetadata fullSchema);
}

public interface IBusinessContextAutoGenerator
{
    Task<List<AutoGeneratedTableContext>> GenerateTableContextsAsync();
    Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsAsync();
    Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsAsync(List<string> specificTables);
    Task<AutoGeneratedTableContext> GenerateTableContextAsync(string tableName, string schemaName);
    Task<List<AutoGeneratedGlossaryTerm>> GenerateColumnGlossaryAsync(string tableName, string schemaName);
    Task<BusinessRelationshipAnalysis> AnalyzeTableRelationshipsAsync();

    // Progress-aware versions
    Task<List<AutoGeneratedTableContext>> GenerateTableContextsAsync(Func<string, string, string?, Task>? progressCallback = null);
    Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsAsync(List<string> specificTables, Func<string, string, string?, Task>? progressCallback = null);
    Task<AutoGeneratedTableContext> GenerateTableContextAsync(string tableName, string schemaName, Func<string, string, string?, Task>? progressCallback = null);

    // Mock mode versions
    Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsAsync(List<string> specificTables, Func<string, string, string?, Task>? progressCallback = null, bool mockMode = false);
    Task<AutoGeneratedTableContext> GenerateTableContextAsync(string tableName, string schemaName, Func<string, string, string?, Task>? progressCallback = null, bool mockMode = false);
}

public interface IQueryOptimizer
{
    Task<OptimizedQuery> OptimizeAsync(List<SqlCandidate> candidates, UserContext context);
    Task<List<SqlCandidate>> GenerateCandidatesAsync(SemanticAnalysis analysis, SchemaContext schema);
    Task<QueryPerformancePrediction> PredictPerformanceAsync(string sql, SchemaMetadata schema);
    Task<string> RewriteForPerformanceAsync(string sql);
}

public interface ISchemaService
{
    Task<SchemaMetadata> GetSchemaMetadataAsync(string? dataSource = null);
    Task<SchemaMetadata> RefreshSchemaMetadataAsync(string? dataSource = null);
    Task<string> GetSchemaSummaryAsync(string? dataSource = null);
    Task<TableMetadata?> GetTableMetadataAsync(string tableName, string? schema = null);
    Task<List<SchemaSuggestion>> GetSchemaSuggestionsAsync(string userId);
    Task<bool> ValidateTableAccessAsync(string tableName, string userId);
    Task<List<string>> GetAccessibleTablesAsync(string userId);
    Task UpdateTableStatisticsAsync(string tableName);
    Task<DataQualityScore> AssessDataQualityAsync(string tableName);

    // Additional methods for compatibility
    Task<SchemaMetadata> GetSchemaAsync(string? dataSource = null);
    Task<TableMetadata?> GetTableInfoAsync(string tableName, string? schema = null);
    Task<List<string>> GetTableNamesAsync(string? schema = null);
    Task RefreshSchemaAsync(string? dataSource = null);
}

public interface ISqlQueryService
{
    Task<QueryResult> ExecuteSelectQueryAsync(string sql, QueryOptions? options = null);
    Task<QueryResult> ExecuteSelectQueryAsync(string sql, QueryOptions? options, CancellationToken cancellationToken);
    Task<bool> ValidateSqlAsync(string sql);
    Task<string> OptimizeSqlAsync(string sql);
    Task<QueryExecutionPlan> GetExecutionPlanAsync(string sql);
    Task<QueryPerformanceMetrics> GetQueryPerformanceAsync(string sql);
    Task<bool> TestConnectionAsync(string? dataSource = null);
    Task<List<string>> GetAvailableDataSourcesAsync();
}

public interface IPromptService
{
    Task<string> BuildQueryPromptAsync(string naturalLanguageQuery, SchemaMetadata schema, string? context = null);
    Task<PromptDetails> BuildDetailedQueryPromptAsync(string naturalLanguageQuery, SchemaMetadata schema, string? context = null);
    Task<string> BuildInsightPromptAsync(string query, QueryResult result);
    Task<string> BuildVisualizationPromptAsync(string query, QueryResult result);
    Task<PromptTemplate> GetPromptTemplateAsync(string templateName, string? version = null);
    Task<PromptTemplate> CreatePromptTemplateAsync(PromptTemplate template);
    Task<PromptTemplate> UpdatePromptTemplateAsync(PromptTemplate template);
    Task<List<PromptTemplate>> GetPromptTemplatesAsync();

    // Enhanced streaming prompt methods
    Task<string> BuildSQLGenerationPromptAsync(string prompt, SchemaMetadata? schema = null, CoreModels.QueryContext? context = null);
    Task<string> BuildInsightGenerationPromptAsync(string query, object[] data, CoreModels.AnalysisContext? context = null);
    Task<string> BuildSQLExplanationPromptAsync(string sql, CoreModels.StreamingQueryComplexity complexity = CoreModels.StreamingQueryComplexity.Medium);
    Task<PromptPerformanceMetrics> GetPromptPerformanceAsync(string templateName);
}

public interface ITuningService
{
    // Dashboard
    Task<TuningDashboardData> GetDashboardDataAsync();

    // Business Table Info
    Task<List<BusinessTableInfoDto>> GetBusinessTablesAsync();
    Task<BusinessTableInfoDto?> GetBusinessTableAsync(long id);
    Task<BusinessTableInfoDto> CreateBusinessTableAsync(CreateTableInfoRequest request, string userId);
    Task<BusinessTableInfoDto?> UpdateBusinessTableAsync(long id, CreateTableInfoRequest request, string userId);
    Task<bool> DeleteBusinessTableAsync(long id);

    // Query Patterns
    Task<List<QueryPatternDto>> GetQueryPatternsAsync();
    Task<QueryPatternDto?> GetQueryPatternAsync(long id);
    Task<QueryPatternDto> CreateQueryPatternAsync(CreateQueryPatternRequest request, string userId);
    Task<QueryPatternDto?> UpdateQueryPatternAsync(long id, CreateQueryPatternRequest request, string userId);
    Task<bool> DeleteQueryPatternAsync(long id);
    Task<string> TestQueryPatternAsync(long id, string naturalLanguageQuery);

    // Business Glossary
    Task<List<BusinessGlossaryDto>> GetGlossaryTermsAsync();
    Task<BusinessGlossaryDto> CreateGlossaryTermAsync(BusinessGlossaryDto request, string userId);
    Task<BusinessGlossaryDto?> UpdateGlossaryTermAsync(long id, BusinessGlossaryDto request, string userId);
    Task<bool> DeleteGlossaryTermAsync(long id);

    // AI Settings
    Task<List<AITuningSettingsDto>> GetAISettingsAsync();
    Task<AITuningSettingsDto?> UpdateAISettingAsync(long id, AITuningSettingsDto request, string userId);

    // Auto-Generation
    Task<AutoGenerationResponse> AutoGenerateBusinessContextAsync(AutoGenerationRequest request, string userId);
    Task<List<AutoGeneratedTableContext>> AutoGenerateTableContextsAsync(string userId);
    Task<List<AutoGeneratedGlossaryTerm>> AutoGenerateGlossaryTermsAsync(string userId);
    Task<BusinessRelationshipAnalysis> AutoGenerateRelationshipAnalysisAsync(string userId);
    Task<AutoGeneratedTableContext> AutoGenerateTableContextAsync(string tableName, string schemaName, string userId);
    Task ApplyAutoGeneratedContextAsync(AutoGenerationResponse autoGenerated, string userId);
}

public interface ISchemaManagementService
{
    // Business Schema Management
    Task<List<BusinessSchemaDto>> GetBusinessSchemasAsync(string userId);
    Task<BusinessSchemaDto> GetBusinessSchemaAsync(Guid schemaId, string userId);
    Task<BusinessSchemaDto> CreateBusinessSchemaAsync(CreateBusinessSchemaRequest request, string userId);
    Task<BusinessSchemaDto> UpdateBusinessSchemaAsync(Guid schemaId, UpdateBusinessSchemaRequest request, string userId);
    Task DeleteBusinessSchemaAsync(Guid schemaId, string userId);
    Task<BusinessSchemaDto> SetDefaultSchemaAsync(Guid schemaId, string userId);

    // Schema Version Management
    Task<List<BusinessSchemaVersionDto>> GetSchemaVersionsAsync(Guid schemaId, string userId);
    Task<DetailedSchemaVersionDto> GetSchemaVersionAsync(Guid versionId, string userId);
    Task<BusinessSchemaVersionDto> CreateSchemaVersionAsync(CreateSchemaVersionRequest request, string userId);
    Task<BusinessSchemaVersionDto> SetCurrentVersionAsync(Guid versionId, string userId);
    Task DeleteSchemaVersionAsync(Guid versionId, string userId);

    // Apply Auto-Generated Content to Schema
    Task<BusinessSchemaVersionDto> ApplyToSchemaAsync(ApplyToSchemaRequest request, string userId);

    // Schema Content Management
    Task<SchemaTableContextDto> UpdateTableContextAsync(Guid tableContextId, SchemaTableContextDto request, string userId);
    Task<SchemaColumnContextDto> UpdateColumnContextAsync(Guid columnContextId, SchemaColumnContextDto request, string userId);
    Task<SchemaGlossaryTermDto> UpdateGlossaryTermAsync(Guid termId, SchemaGlossaryTermDto request, string userId);
    Task<SchemaRelationshipDto> UpdateRelationshipAsync(Guid relationshipId, SchemaRelationshipDto request, string userId);

    // User Preferences
    Task<List<UserSchemaPreferenceDto>> GetUserSchemaPreferencesAsync(string userId);
    Task<UserSchemaPreferenceDto> SetUserDefaultSchemaAsync(Guid schemaVersionId, string userId);
    Task<BusinessSchemaVersionDto?> GetUserDefaultSchemaAsync(string userId);

    // Schema Comparison
    Task<SchemaComparisonDto> CompareSchemaVersionsAsync(Guid sourceVersionId, Guid targetVersionId, string userId);

    // Schema Export/Import
    Task<DetailedSchemaVersionDto> ExportSchemaVersionAsync(Guid versionId, string userId);
    Task<BusinessSchemaVersionDto> ImportSchemaVersionAsync(Guid schemaId, DetailedSchemaVersionDto schemaData, string userId);
}

/// <summary>
/// Unified cache service interface supporting both memory and distributed caching
/// Consolidates MemoryOptimizedCacheService and TestCacheService functionality
/// </summary>
public interface ICacheService
{
    #region Basic Cache Operations

    /// <summary>
    /// Get cached value by key
    /// </summary>
    Task<T?> GetAsync<T>(string key) where T : class;

    /// <summary>
    /// Set cached value with optional expiry
    /// </summary>
    Task SetAsync<T>(string key, T value, TimeSpan? expiry = null) where T : class;

    /// <summary>
    /// Remove cached value by key
    /// </summary>
    Task RemoveAsync(string key);

    /// <summary>
    /// Remove cached values matching pattern
    /// </summary>
    Task RemovePatternAsync(string pattern);

    /// <summary>
    /// Check if key exists in cache
    /// </summary>
    Task<bool> ExistsAsync(string key);

    #endregion

    #region Advanced Cache Operations

    /// <summary>
    /// Increment numeric value atomically
    /// </summary>
    Task<long> IncrementAsync(string key, long value = 1);

    /// <summary>
    /// Get time-to-live for cached key
    /// </summary>
    Task<TimeSpan?> GetTtlAsync(string key);

    /// <summary>
    /// Set value only if key doesn't exist
    /// </summary>
    Task<bool> SetIfNotExistsAsync<T>(string key, T value, TimeSpan? expiry = null) where T : class;

    /// <summary>
    /// Get multiple values by keys
    /// </summary>
    Task<Dictionary<string, T?>> GetMultipleAsync<T>(string[] keys) where T : class;

    /// <summary>
    /// Set multiple values at once
    /// </summary>
    Task SetMultipleAsync<T>(Dictionary<string, T> keyValuePairs, TimeSpan? expiry = null) where T : class;

    #endregion

    #region Cache Management

    /// <summary>
    /// Clear all cached values
    /// </summary>
    Task ClearAllAsync();

    /// <summary>
    /// Get cache statistics
    /// </summary>
    Task<CacheStatistics> GetStatisticsAsync();

    /// <summary>
    /// Refresh cache entry (extend TTL)
    /// </summary>
    Task<bool> RefreshAsync(string key, TimeSpan? newExpiry = null);

    #endregion
}

/// <summary>
/// Cache statistics for monitoring and diagnostics
/// </summary>
public class CacheStatistics
{
    public long TotalKeys { get; set; }
    public long HitCount { get; set; }
    public long MissCount { get; set; }
    public double HitRatio => TotalRequests > 0 ? (double)HitCount / TotalRequests : 0;
    public long TotalRequests => HitCount + MissCount;
    public long MemoryUsage { get; set; }
    public DateTime LastUpdated { get; set; } = DateTime.UtcNow;
}

public interface IUserService
{
    Task<UserInfo?> GetUserAsync(string userId);
    Task<UserInfo> UpdateUserPreferencesAsync(string userId, UserPreferences preferences);
    Task<List<string>> GetUserPermissionsAsync(string userId);
    Task<bool> HasPermissionAsync(string userId, string permission);
    Task<UserSession> CreateSessionAsync(string userId, string? ipAddress = null, string? userAgent = null);
    Task<UserSession?> GetSessionAsync(string sessionId);
    Task UpdateSessionActivityAsync(string sessionId);
    Task EndSessionAsync(string sessionId);
    Task LogUserActivityAsync(UserActivity activity);
    Task<List<UserActivity>> GetUserActivityAsync(string userId, DateTime? from = null, DateTime? to = null);
    Task<int> GetTotalActiveUsersAsync();
}

public interface IAuditService
{
    Task LogAsync(string action, string userId, string? entityType = null, string? entityId = null,
                  object? details = null, string? ipAddress = null, string? userAgent = null);
    Task LogQueryAsync(string userId, string sessionId, string naturalLanguageQuery, string generatedSQL,
                       bool successful, int executionTimeMs, string? error = null);
    Task LogSecurityEventAsync(string eventType, string userId, string? details = null,
                               string? ipAddress = null, string severity = "Info");
    Task<List<AuditLogEntry>> GetAuditLogsAsync(string? userId = null, DateTime? from = null,
                                                DateTime? to = null, string? action = null);
    Task<SecurityReport> GenerateSecurityReportAsync(DateTime from, DateTime to);
    Task<UsageReport> GenerateUsageReportAsync(DateTime from, DateTime to);
}


