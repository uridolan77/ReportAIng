using BIReportingCopilot.Core.Interfaces;
using BIReportingCopilot.Core.Models;
using Microsoft.Extensions.Logging;
using System.Text.Json;
using System.Text.RegularExpressions;

namespace BIReportingCopilot.Infrastructure.AI;

public class BusinessContextAutoGenerator : IBusinessContextAutoGenerator
{
    private readonly ISchemaService _schemaService;
    private readonly IOpenAIService _openAIService;
    private readonly ILogger<BusinessContextAutoGenerator> _logger;

    // Gaming/Casino domain knowledge for better context generation
    private readonly Dictionary<string, string> _domainPatterns = new()
    {
        ["player"] = "Gaming customer or user account",
        ["deposit"] = "Money added to player account",
        ["withdrawal"] = "Money removed from player account",
        ["bet"] = "Wager placed by player",
        ["win"] = "Amount won by player",
        ["bonus"] = "Promotional credit given to player",
        ["game"] = "Casino game or slot machine",
        ["session"] = "Gaming session or login period",
        ["transaction"] = "Financial transaction",
        ["balance"] = "Account balance or available funds",
        ["currency"] = "Money denomination",
        ["country"] = "Geographic location",
        ["whitelabel"] = "Brand or operator",
        ["casino"] = "Casino gaming platform",
        ["sport"] = "Sports betting platform",
        ["live"] = "Live dealer games",
        ["bingo"] = "Bingo gaming platform"
    };

    public BusinessContextAutoGenerator(
        ISchemaService schemaService,
        IOpenAIService openAIService,
        ILogger<BusinessContextAutoGenerator> logger)
    {
        _schemaService = schemaService;
        _openAIService = openAIService;
        _logger = logger;
    }

    public async Task<List<AutoGeneratedTableContext>> GenerateTableContextsAsync()
    {
        _logger.LogInformation("Starting auto-generation of table contexts");
        var results = new List<AutoGeneratedTableContext>();

        try
        {
            var schema = await _schemaService.GetSchemaMetadataAsync();

            foreach (var table in schema.Tables)
            {
                try
                {
                    var context = await GenerateTableContextAsync(table.Name, table.Schema);
                    results.Add(context);
                    _logger.LogDebug("Generated context for table {Schema}.{Table}", table.Schema, table.Name);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error generating context for table {Schema}.{Table}", table.Schema, table.Name);
                }
            }

            _logger.LogInformation("Completed auto-generation for {Count} tables", results.Count);
            return results;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in GenerateTableContextsAsync");
            throw;
        }
    }

    public async Task<AutoGeneratedTableContext> GenerateTableContextAsync(string tableName, string schemaName)
    {
        _logger.LogDebug("Generating context for table {Schema}.{Table}", schemaName, tableName);

        try
        {
            var tableMetadata = await _schemaService.GetTableMetadataAsync(tableName, schemaName);
            if (tableMetadata == null)
            {
                throw new ArgumentException($"Table {schemaName}.{tableName} not found");
            }

            // Build AI prompt for table analysis
            var prompt = BuildTableAnalysisPrompt(tableMetadata);

            // Get AI analysis
            var aiResponse = await _openAIService.GenerateSQLAsync(prompt);

            // Parse AI response and create context
            var context = ParseTableContextResponse(aiResponse, tableMetadata);

            // Generate column contexts
            context.Columns = await GenerateColumnContextsAsync(tableMetadata);

            // Analyze relationships
            context.RelatedTables = await FindRelatedTablesAsync(tableMetadata);

            // Calculate confidence score
            context.ConfidenceScore = CalculateTableConfidenceScore(context, tableMetadata);

            return context;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating context for table {Schema}.{Table}", schemaName, tableName);

            // Return fallback context
            return CreateFallbackTableContext(tableName, schemaName);
        }
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsAsync()
    {
        _logger.LogInformation("Starting auto-generation of glossary terms");
        var results = new List<AutoGeneratedGlossaryTerm>();

        try
        {
            var schema = await _schemaService.GetSchemaMetadataAsync();
            var allTerms = new HashSet<string>();

            // Extract terms from table and column names
            foreach (var table in schema.Tables)
            {
                // Add table name terms
                var tableTerms = ExtractBusinessTerms(table.Name);
                foreach (var term in tableTerms)
                {
                    allTerms.Add(term.ToLowerInvariant());
                }

                // Add column name terms
                foreach (var column in table.Columns)
                {
                    var columnTerms = ExtractBusinessTerms(column.Name);
                    foreach (var term in columnTerms)
                    {
                        allTerms.Add(term.ToLowerInvariant());
                    }
                }
            }

            // Generate definitions for unique terms
            foreach (var term in allTerms.Where(t => t.Length > 2))
            {
                try
                {
                    var glossaryTerm = await GenerateGlossaryTermAsync(term, schema);
                    if (glossaryTerm.ConfidenceScore >= 0.6)
                    {
                        results.Add(glossaryTerm);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Error generating glossary term for: {Term}", term);
                }
            }

            _logger.LogInformation("Generated {Count} glossary terms", results.Count);
            return results;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in GenerateGlossaryTermsAsync");
            throw;
        }
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateColumnGlossaryAsync(string tableName, string schemaName)
    {
        var results = new List<AutoGeneratedGlossaryTerm>();

        try
        {
            var tableMetadata = await _schemaService.GetTableMetadataAsync(tableName, schemaName);
            if (tableMetadata == null) return results;

            var schema = await _schemaService.GetSchemaMetadataAsync();

            foreach (var column in tableMetadata.Columns)
            {
                var terms = ExtractBusinessTerms(column.Name);
                foreach (var term in terms.Where(t => t.Length > 2))
                {
                    var glossaryTerm = await GenerateGlossaryTermAsync(term, schema, tableName, column.Name);
                    if (glossaryTerm.ConfidenceScore >= 0.6)
                    {
                        results.Add(glossaryTerm);
                    }
                }
            }

            return results;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating column glossary for {Schema}.{Table}", schemaName, tableName);
            return results;
        }
    }

    public async Task<BusinessRelationshipAnalysis> AnalyzeTableRelationshipsAsync()
    {
        _logger.LogInformation("Starting table relationship analysis");

        try
        {
            var schema = await _schemaService.GetSchemaMetadataAsync();
            var analysis = new BusinessRelationshipAnalysis();

            // Analyze foreign key relationships
            analysis.Relationships = await AnalyzeForeignKeyRelationships(schema);

            // Identify business domains
            analysis.BusinessDomains = IdentifyBusinessDomains(schema);

            // Analyze data flows
            analysis.DataFlows = AnalyzeDataFlows(schema, analysis.Relationships);

            // Calculate overall confidence
            analysis.OverallConfidence = CalculateRelationshipConfidence(analysis);

            _logger.LogInformation("Completed relationship analysis with {RelCount} relationships, {DomainCount} domains",
                analysis.Relationships.Count, analysis.BusinessDomains.Count);

            return analysis;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in AnalyzeTableRelationshipsAsync");
            throw;
        }
    }

    private string BuildTableAnalysisPrompt(TableMetadata table)
    {
        var prompt = $@"
Analyze this database table and provide business context for a gaming/casino platform:

Table: {table.Schema}.{table.Name}
Columns: {string.Join(", ", table.Columns.Select(c => $"{c.Name} ({c.DataType})"))}

Based on the table and column names, provide:
1. Business Purpose: What is this table used for in business terms?
2. Business Context: How does this table fit into the overall business process?
3. Primary Use Case: What is the main business scenario this table supports?
4. Key Business Metrics: What important business metrics can be derived from this table?
5. Common Query Patterns: What types of business questions would this table help answer?
6. Business Rules: What business rules or constraints might apply to this data?

Focus on gaming/casino business terminology. Consider concepts like players, deposits, withdrawals, bets, wins, bonuses, games, sessions, etc.

Respond in JSON format:
{{
  ""businessPurpose"": ""..."",
  ""businessContext"": ""..."",
  ""primaryUseCase"": ""..."",
  ""keyBusinessMetrics"": [""...""],
  ""commonQueryPatterns"": [""...""],
  ""businessRules"": ""...""
}}";

        return prompt;
    }

    private AutoGeneratedTableContext ParseTableContextResponse(string aiResponse, TableMetadata table)
    {
        try
        {
            // Clean up the response to extract JSON
            var jsonMatch = Regex.Match(aiResponse, @"\{.*\}", RegexOptions.Singleline);
            if (!jsonMatch.Success)
            {
                return CreateFallbackTableContext(table.Name, table.Schema);
            }

            var jsonResponse = JsonSerializer.Deserialize<Dictionary<string, object>>(jsonMatch.Value);
            if (jsonResponse == null)
            {
                return CreateFallbackTableContext(table.Name, table.Schema);
            }

            return new AutoGeneratedTableContext
            {
                TableName = table.Name,
                SchemaName = table.Schema,
                BusinessPurpose = GetStringValue(jsonResponse, "businessPurpose"),
                BusinessContext = GetStringValue(jsonResponse, "businessContext"),
                PrimaryUseCase = GetStringValue(jsonResponse, "primaryUseCase"),
                KeyBusinessMetrics = GetStringArrayValue(jsonResponse, "keyBusinessMetrics"),
                CommonQueryPatterns = GetStringArrayValue(jsonResponse, "commonQueryPatterns"),
                BusinessRules = GetStringValue(jsonResponse, "businessRules"),
                GeneratedAt = DateTime.UtcNow,
                IsAutoGenerated = true
            };
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error parsing AI response for table {Table}, using fallback", table.Name);
            return CreateFallbackTableContext(table.Name, table.Schema);
        }
    }

    private AutoGeneratedTableContext CreateFallbackTableContext(string tableName, string schemaName)
    {
        var businessName = GenerateBusinessName(tableName);

        return new AutoGeneratedTableContext
        {
            TableName = tableName,
            SchemaName = schemaName,
            BusinessPurpose = $"Data storage for {businessName}",
            BusinessContext = $"This table contains information related to {businessName} in the gaming platform",
            PrimaryUseCase = $"Store and retrieve {businessName} data",
            KeyBusinessMetrics = new List<string> { $"{businessName} count", $"{businessName} activity" },
            CommonQueryPatterns = new List<string> { $"Show all {businessName}", $"Count {businessName}" },
            BusinessRules = "Standard data integrity and business rules apply",
            ConfidenceScore = 0.3,
            GeneratedAt = DateTime.UtcNow,
            IsAutoGenerated = true
        };
    }

    private async Task<List<AutoGeneratedColumnContext>> GenerateColumnContextsAsync(TableMetadata table)
    {
        var results = new List<AutoGeneratedColumnContext>();

        foreach (var column in table.Columns)
        {
            var context = new AutoGeneratedColumnContext
            {
                ColumnName = column.Name,
                BusinessName = GenerateBusinessName(column.Name),
                BusinessDescription = GenerateColumnDescription(column, table.Name),
                DataType = column.DataType,
                BusinessDataType = MapToBusinessDataType(column.DataType),
                IsPrimaryKey = column.IsPrimaryKey,
                IsForeignKey = column.IsForeignKey,
                ConfidenceScore = CalculateColumnConfidenceScore(column),
                IsAutoGenerated = true
            };

            // Add business rules based on column patterns
            context.BusinessRules = GenerateColumnBusinessRules(column);
            context.CommonUseCases = GenerateColumnUseCases(column, table.Name);

            results.Add(context);
        }

        return results;
    }

    private async Task<List<string>> FindRelatedTablesAsync(TableMetadata table)
    {
        var relatedTables = new List<string>();

        try
        {
            var schema = await _schemaService.GetSchemaMetadataAsync();

            // Find tables with similar naming patterns
            var tableNameParts = ExtractBusinessTerms(table.Name);

            foreach (var otherTable in schema.Tables.Where(t => t.Name != table.Name))
            {
                var otherNameParts = ExtractBusinessTerms(otherTable.Name);
                var commonTerms = tableNameParts.Intersect(otherNameParts, StringComparer.OrdinalIgnoreCase).Count();

                if (commonTerms > 0)
                {
                    relatedTables.Add($"{otherTable.Schema}.{otherTable.Name}");
                }
            }

            // Find tables with foreign key relationships
            foreach (var column in table.Columns.Where(c => c.IsForeignKey))
            {
                // Simple heuristic: look for tables with similar column names
                var potentialReferences = schema.Tables
                    .Where(t => t.Columns.Any(c => c.Name.Equals(column.Name, StringComparison.OrdinalIgnoreCase) && c.IsPrimaryKey))
                    .Select(t => $"{t.Schema}.{t.Name}")
                    .ToList();

                relatedTables.AddRange(potentialReferences);
            }

            return relatedTables.Distinct().ToList();
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error finding related tables for {Table}", table.Name);
            return relatedTables;
        }
    }

    private async Task<AutoGeneratedGlossaryTerm> GenerateGlossaryTermAsync(string term, SchemaMetadata schema, string? sourceTable = null, string? sourceColumn = null)
    {
        try
        {
            // Check if we have domain knowledge for this term
            var definition = GenerateTermDefinition(term);
            var category = DetermineTermCategory(term);
            var synonyms = GenerateTermSynonyms(term);
            var relatedTerms = FindRelatedTerms(term, schema);

            var glossaryTerm = new AutoGeneratedGlossaryTerm
            {
                Term = term,
                Definition = definition,
                BusinessContext = GenerateTermBusinessContext(term),
                Synonyms = synonyms,
                RelatedTerms = relatedTerms,
                Category = category,
                ConfidenceScore = CalculateTermConfidenceScore(term),
                GeneratedAt = DateTime.UtcNow,
                IsAutoGenerated = true
            };

            if (!string.IsNullOrEmpty(sourceTable))
            {
                glossaryTerm.SourceTables.Add(sourceTable);
            }

            if (!string.IsNullOrEmpty(sourceColumn))
            {
                glossaryTerm.SourceColumns.Add(sourceColumn);
            }

            return glossaryTerm;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error generating glossary term for: {Term}", term);
            return CreateFallbackGlossaryTerm(term);
        }
    }

    private async Task<List<TableRelationship>> AnalyzeForeignKeyRelationships(SchemaMetadata schema)
    {
        var relationships = new List<TableRelationship>();

        foreach (var table in schema.Tables)
        {
            foreach (var column in table.Columns.Where(c => c.IsForeignKey))
            {
                // Find potential referenced tables
                var referencedTables = schema.Tables
                    .Where(t => t.Columns.Any(c => c.Name.Equals(column.Name, StringComparison.OrdinalIgnoreCase) && c.IsPrimaryKey))
                    .ToList();

                foreach (var referencedTable in referencedTables)
                {
                    var relationship = new TableRelationship
                    {
                        FromTable = table.Name,
                        FromSchema = table.Schema,
                        ToTable = referencedTable.Name,
                        ToSchema = referencedTable.Schema,
                        RelationshipType = "ManyToOne",
                        BusinessRelationship = GenerateBusinessRelationship(table.Name, referencedTable.Name),
                        ColumnMappings = new List<ColumnMapping>
                        {
                            new ColumnMapping
                            {
                                FromColumn = column.Name,
                                ToColumn = column.Name,
                                BusinessMeaning = GenerateColumnRelationshipMeaning(column.Name, table.Name, referencedTable.Name)
                            }
                        },
                        ConfidenceScore = 0.8
                    };

                    relationships.Add(relationship);
                }
            }
        }

        return relationships;
    }

    private List<BusinessDomain> IdentifyBusinessDomains(SchemaMetadata schema)
    {
        var domains = new List<BusinessDomain>();

        // Gaming domain patterns
        var gamingPatterns = new Dictionary<string, List<string>>
        {
            ["Player Management"] = new() { "player", "user", "account", "profile" },
            ["Financial Transactions"] = new() { "deposit", "withdrawal", "transaction", "payment", "balance" },
            ["Gaming Activity"] = new() { "bet", "win", "game", "session", "play" },
            ["Bonus System"] = new() { "bonus", "promotion", "reward", "campaign" },
            ["Platform Management"] = new() { "whitelabel", "brand", "operator", "config" },
            ["Geographic Data"] = new() { "country", "region", "currency", "locale" }
        };

        foreach (var pattern in gamingPatterns)
        {
            var matchingTables = schema.Tables
                .Where(t => pattern.Value.Any(keyword =>
                    t.Name.ToLowerInvariant().Contains(keyword) ||
                    t.Columns.Any(c => c.Name.ToLowerInvariant().Contains(keyword))))
                .Select(t => $"{t.Schema}.{t.Name}")
                .ToList();

            if (matchingTables.Any())
            {
                domains.Add(new BusinessDomain
                {
                    DomainName = pattern.Key,
                    Description = $"Tables related to {pattern.Key.ToLowerInvariant()} in the gaming platform",
                    Tables = matchingTables,
                    KeyConcepts = pattern.Value,
                    ConfidenceScore = 0.7
                });
            }
        }

        return domains;
    }

    private List<DataFlow> AnalyzeDataFlows(SchemaMetadata schema, List<TableRelationship> relationships)
    {
        var dataFlows = new List<DataFlow>();

        // Common gaming data flows
        var commonFlows = new Dictionary<string, (string process, List<string> sequence)>
        {
            ["Player Registration"] = ("New player onboarding", new() { "players", "accounts", "profiles" }),
            ["Deposit Process"] = ("Player funding account", new() { "players", "transactions", "balances" }),
            ["Gaming Session"] = ("Player gaming activity", new() { "sessions", "bets", "games", "wins" }),
            ["Withdrawal Process"] = ("Player cashing out", new() { "balances", "withdrawals", "transactions" }),
            ["Bonus Allocation"] = ("Bonus distribution", new() { "bonuses", "players", "balances" })
        };

        foreach (var flow in commonFlows)
        {
            var matchingTables = new List<string>();

            foreach (var tablePattern in flow.Value.sequence)
            {
                var matches = schema.Tables
                    .Where(t => t.Name.ToLowerInvariant().Contains(tablePattern))
                    .Select(t => $"{t.Schema}.{t.Name}")
                    .ToList();

                matchingTables.AddRange(matches);
            }

            if (matchingTables.Count >= 2)
            {
                dataFlows.Add(new DataFlow
                {
                    FlowName = flow.Key,
                    BusinessProcess = flow.Value.process,
                    TableSequence = matchingTables.Distinct().ToList(),
                    Description = $"Data flow for {flow.Value.process} involving {matchingTables.Count} tables",
                    ConfidenceScore = 0.6
                });
            }
        }

        return dataFlows;
    }

    // Helper methods for business context generation
    private string GenerateBusinessName(string technicalName)
    {
        // Convert technical names to business-friendly names
        var name = technicalName.Replace("tbl_", "").Replace("_", " ");

        // Apply domain-specific transformations
        foreach (var pattern in _domainPatterns)
        {
            if (name.ToLowerInvariant().Contains(pattern.Key))
            {
                name = name.Replace(pattern.Key, pattern.Value, StringComparison.OrdinalIgnoreCase);
            }
        }

        return System.Globalization.CultureInfo.CurrentCulture.TextInfo.ToTitleCase(name.ToLowerInvariant());
    }

    private string GenerateColumnDescription(ColumnMetadata column, string tableName)
    {
        var businessName = GenerateBusinessName(column.Name);
        var tableBusinessName = GenerateBusinessName(tableName);

        if (column.IsPrimaryKey)
        {
            return $"Unique identifier for {tableBusinessName}";
        }

        if (column.IsForeignKey)
        {
            return $"Reference to related {businessName} record";
        }

        // Check for common patterns
        var lowerName = column.Name.ToLowerInvariant();
        if (lowerName.Contains("date") || lowerName.Contains("time"))
        {
            return $"Date/time when {businessName} occurred";
        }

        if (lowerName.Contains("amount") || lowerName.Contains("value"))
        {
            return $"Monetary amount for {businessName}";
        }

        if (lowerName.Contains("count") || lowerName.Contains("number"))
        {
            return $"Count or number of {businessName}";
        }

        return $"{businessName} information for {tableBusinessName}";
    }

    private string MapToBusinessDataType(string technicalDataType)
    {
        return technicalDataType.ToLowerInvariant() switch
        {
            var t when t.Contains("varchar") || t.Contains("char") || t.Contains("text") => "Text",
            var t when t.Contains("int") || t.Contains("bigint") => "Number",
            var t when t.Contains("decimal") || t.Contains("money") || t.Contains("float") => "Currency/Decimal",
            var t when t.Contains("date") || t.Contains("time") => "Date/Time",
            var t when t.Contains("bit") || t.Contains("bool") => "Yes/No",
            var t when t.Contains("uniqueidentifier") => "Unique ID",
            _ => "Data"
        };
    }

    private List<string> GenerateColumnBusinessRules(ColumnMetadata column)
    {
        var rules = new List<string>();

        if (!column.IsNullable)
        {
            rules.Add("Required field - cannot be empty");
        }

        if (column.IsPrimaryKey)
        {
            rules.Add("Must be unique across all records");
        }

        var lowerName = column.Name.ToLowerInvariant();
        if (lowerName.Contains("email"))
        {
            rules.Add("Must be valid email format");
        }

        if (lowerName.Contains("amount") || lowerName.Contains("balance"))
        {
            rules.Add("Must be non-negative value");
        }

        if (lowerName.Contains("date"))
        {
            rules.Add("Must be valid date");
        }

        return rules;
    }

    private List<string> GenerateColumnUseCases(ColumnMetadata column, string tableName)
    {
        var useCases = new List<string>();
        var businessName = GenerateBusinessName(column.Name);
        var tableBusinessName = GenerateBusinessName(tableName);

        useCases.Add($"Filter {tableBusinessName} by {businessName}");
        useCases.Add($"Sort {tableBusinessName} by {businessName}");

        var lowerName = column.Name.ToLowerInvariant();
        if (lowerName.Contains("amount") || lowerName.Contains("value"))
        {
            useCases.Add($"Calculate total {businessName}");
            useCases.Add($"Calculate average {businessName}");
        }

        if (lowerName.Contains("date"))
        {
            useCases.Add($"Group by {businessName} period");
            useCases.Add($"Filter by {businessName} range");
        }

        if (lowerName.Contains("count"))
        {
            useCases.Add($"Sum total {businessName}");
        }

        return useCases;
    }

    private List<string> ExtractBusinessTerms(string name)
    {
        // Split on common separators and extract meaningful terms
        var terms = new List<string>();
        var cleanName = name.Replace("tbl_", "").Replace("_", " ");

        // Split on various separators
        var parts = Regex.Split(cleanName, @"[_\s\-\.]+", RegexOptions.IgnoreCase)
            .Where(p => !string.IsNullOrWhiteSpace(p) && p.Length > 1)
            .ToList();

        terms.AddRange(parts);

        // Also try camelCase splitting
        var camelCaseParts = Regex.Split(name, @"(?<!^)(?=[A-Z])", RegexOptions.IgnoreCase)
            .Where(p => !string.IsNullOrWhiteSpace(p) && p.Length > 1)
            .ToList();

        terms.AddRange(camelCaseParts);

        return terms.Distinct(StringComparer.OrdinalIgnoreCase).ToList();
    }

    private string GenerateTermDefinition(string term)
    {
        var lowerTerm = term.ToLowerInvariant();

        // Check domain patterns first
        if (_domainPatterns.ContainsKey(lowerTerm))
        {
            return _domainPatterns[lowerTerm];
        }

        // Generate based on common patterns
        if (lowerTerm.Contains("id") || lowerTerm.EndsWith("id"))
        {
            return "Unique identifier used to reference records";
        }

        if (lowerTerm.Contains("date") || lowerTerm.Contains("time"))
        {
            return "Date and time information";
        }

        if (lowerTerm.Contains("amount") || lowerTerm.Contains("value"))
        {
            return "Monetary or numeric value";
        }

        if (lowerTerm.Contains("count") || lowerTerm.Contains("number"))
        {
            return "Numeric count or quantity";
        }

        if (lowerTerm.Contains("name") || lowerTerm.Contains("title"))
        {
            return "Descriptive name or title";
        }

        if (lowerTerm.Contains("status") || lowerTerm.Contains("state"))
        {
            return "Current status or state";
        }

        return $"Business term related to {term}";
    }

    private string DetermineTermCategory(string term)
    {
        var lowerTerm = term.ToLowerInvariant();

        if (lowerTerm.Contains("player") || lowerTerm.Contains("user") || lowerTerm.Contains("account"))
            return "Player Management";

        if (lowerTerm.Contains("deposit") || lowerTerm.Contains("withdrawal") || lowerTerm.Contains("transaction") || lowerTerm.Contains("balance"))
            return "Financial";

        if (lowerTerm.Contains("bet") || lowerTerm.Contains("win") || lowerTerm.Contains("game") || lowerTerm.Contains("session"))
            return "Gaming";

        if (lowerTerm.Contains("bonus") || lowerTerm.Contains("promotion") || lowerTerm.Contains("campaign"))
            return "Marketing";

        if (lowerTerm.Contains("country") || lowerTerm.Contains("currency") || lowerTerm.Contains("region"))
            return "Geographic";

        if (lowerTerm.Contains("date") || lowerTerm.Contains("time"))
            return "Temporal";

        if (lowerTerm.Contains("id") || lowerTerm.EndsWith("id"))
            return "Identifier";

        return "Business";
    }

    private List<string> GenerateTermSynonyms(string term)
    {
        var synonyms = new List<string>();
        var lowerTerm = term.ToLowerInvariant();

        var synonymMap = new Dictionary<string, List<string>>
        {
            ["player"] = new() { "user", "customer", "account holder" },
            ["deposit"] = new() { "funding", "top-up", "payment in" },
            ["withdrawal"] = new() { "cashout", "payout", "payment out" },
            ["bet"] = new() { "wager", "stake", "play" },
            ["win"] = new() { "payout", "prize", "winnings" },
            ["bonus"] = new() { "promotion", "reward", "incentive" },
            ["game"] = new() { "slot", "machine", "activity" },
            ["session"] = new() { "login", "visit", "period" },
            ["balance"] = new() { "funds", "amount", "total" },
            ["transaction"] = new() { "payment", "transfer", "movement" }
        };

        foreach (var synonym in synonymMap)
        {
            if (lowerTerm.Contains(synonym.Key))
            {
                synonyms.AddRange(synonym.Value);
            }
        }

        return synonyms.Distinct().ToList();
    }

    private List<string> FindRelatedTerms(string term, SchemaMetadata schema)
    {
        var relatedTerms = new List<string>();
        var lowerTerm = term.ToLowerInvariant();

        // Find terms that appear in the same tables or columns
        foreach (var table in schema.Tables)
        {
            var tableTerms = ExtractBusinessTerms(table.Name);
            if (tableTerms.Any(t => t.Equals(term, StringComparison.OrdinalIgnoreCase)))
            {
                relatedTerms.AddRange(tableTerms.Where(t => !t.Equals(term, StringComparison.OrdinalIgnoreCase)));
            }

            foreach (var column in table.Columns)
            {
                var columnTerms = ExtractBusinessTerms(column.Name);
                if (columnTerms.Any(t => t.Equals(term, StringComparison.OrdinalIgnoreCase)))
                {
                    relatedTerms.AddRange(columnTerms.Where(t => !t.Equals(term, StringComparison.OrdinalIgnoreCase)));
                }
            }
        }

        return relatedTerms.Distinct().Take(5).ToList();
    }

    private string GenerateTermBusinessContext(string term)
    {
        var lowerTerm = term.ToLowerInvariant();

        if (lowerTerm.Contains("player"))
            return "Used in player management and customer relationship processes";

        if (lowerTerm.Contains("deposit") || lowerTerm.Contains("withdrawal"))
            return "Part of financial transaction processing and account management";

        if (lowerTerm.Contains("bet") || lowerTerm.Contains("win"))
            return "Core gaming activity metrics for business analysis";

        if (lowerTerm.Contains("bonus"))
            return "Marketing and player retention strategy component";

        if (lowerTerm.Contains("game") || lowerTerm.Contains("session"))
            return "Gaming platform activity and engagement tracking";

        return $"Business context for {term} in gaming platform operations";
    }

    private AutoGeneratedGlossaryTerm CreateFallbackGlossaryTerm(string term)
    {
        return new AutoGeneratedGlossaryTerm
        {
            Term = term,
            Definition = $"Business term: {term}",
            BusinessContext = $"Used in gaming platform operations",
            Category = "Business",
            ConfidenceScore = 0.3,
            GeneratedAt = DateTime.UtcNow,
            IsAutoGenerated = true
        };
    }

    private string GenerateBusinessRelationship(string fromTable, string toTable)
    {
        var fromBusiness = GenerateBusinessName(fromTable);
        var toBusiness = GenerateBusinessName(toTable);
        return $"{fromBusiness} is related to {toBusiness}";
    }

    private string GenerateColumnRelationshipMeaning(string columnName, string fromTable, string toTable)
    {
        var columnBusiness = GenerateBusinessName(columnName);
        var fromBusiness = GenerateBusinessName(fromTable);
        var toBusiness = GenerateBusinessName(toTable);
        return $"{columnBusiness} links {fromBusiness} to {toBusiness}";
    }

    // Confidence calculation methods
    private double CalculateTableConfidenceScore(AutoGeneratedTableContext context, TableMetadata table)
    {
        double score = 0.5; // Base score

        // Increase confidence based on recognizable patterns
        var lowerTableName = table.Name.ToLowerInvariant();
        foreach (var pattern in _domainPatterns.Keys)
        {
            if (lowerTableName.Contains(pattern))
            {
                score += 0.1;
            }
        }

        // Increase confidence based on column patterns
        var recognizedColumns = table.Columns.Count(c =>
            _domainPatterns.Keys.Any(p => c.Name.ToLowerInvariant().Contains(p)));

        score += (double)recognizedColumns / table.Columns.Count * 0.3;

        // Cap at 0.9 for auto-generated content
        return Math.Min(score, 0.9);
    }

    private double CalculateColumnConfidenceScore(ColumnMetadata column)
    {
        double score = 0.5; // Base score

        var lowerName = column.Name.ToLowerInvariant();

        // Increase confidence for recognized patterns
        foreach (var pattern in _domainPatterns.Keys)
        {
            if (lowerName.Contains(pattern))
            {
                score += 0.2;
                break;
            }
        }

        // Increase confidence for standard patterns
        if (lowerName.Contains("id") || column.IsPrimaryKey || column.IsForeignKey)
            score += 0.1;

        if (lowerName.Contains("date") || lowerName.Contains("time"))
            score += 0.1;

        if (lowerName.Contains("amount") || lowerName.Contains("value"))
            score += 0.1;

        return Math.Min(score, 0.9);
    }

    private double CalculateTermConfidenceScore(string term)
    {
        double score = 0.4; // Base score

        var lowerTerm = term.ToLowerInvariant();

        // High confidence for domain-specific terms
        if (_domainPatterns.ContainsKey(lowerTerm))
        {
            score = 0.8;
        }
        else
        {
            // Check if term contains domain keywords
            foreach (var pattern in _domainPatterns.Keys)
            {
                if (lowerTerm.Contains(pattern))
                {
                    score += 0.2;
                    break;
                }
            }
        }

        // Increase confidence for common business terms
        var businessTerms = new[] { "id", "name", "date", "time", "amount", "count", "status", "type" };
        if (businessTerms.Any(bt => lowerTerm.Contains(bt)))
        {
            score += 0.1;
        }

        return Math.Min(score, 0.9);
    }

    private double CalculateRelationshipConfidence(BusinessRelationshipAnalysis analysis)
    {
        if (!analysis.Relationships.Any())
            return 0.3;

        var avgRelationshipConfidence = analysis.Relationships.Average(r => r.ConfidenceScore);
        var avgDomainConfidence = analysis.BusinessDomains.Any()
            ? analysis.BusinessDomains.Average(d => d.ConfidenceScore)
            : 0.5;

        return (avgRelationshipConfidence + avgDomainConfidence) / 2;
    }

    // Utility methods for parsing AI responses
    private string GetStringValue(Dictionary<string, object> dict, string key)
    {
        if (dict.TryGetValue(key, out var value))
        {
            return value?.ToString() ?? string.Empty;
        }
        return string.Empty;
    }

    private List<string> GetStringArrayValue(Dictionary<string, object> dict, string key)
    {
        if (dict.TryGetValue(key, out var value))
        {
            if (value is JsonElement element && element.ValueKind == JsonValueKind.Array)
            {
                return element.EnumerateArray()
                    .Select(e => e.GetString() ?? string.Empty)
                    .Where(s => !string.IsNullOrEmpty(s))
                    .ToList();
            }
        }
        return new List<string>();
    }
}
