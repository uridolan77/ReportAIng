using BIReportingCopilot.Core.Interfaces;
using BIReportingCopilot.Core.Models;
using Microsoft.Extensions.Logging;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;

namespace BIReportingCopilot.Infrastructure.AI;

public class BusinessContextAutoGenerator : IBusinessContextAutoGenerator
{
    private readonly ISchemaService _schemaService;
    private readonly IAIService _aiService;
    private readonly ILogger<BusinessContextAutoGenerator> _logger;

    // Gaming/Casino domain knowledge for better context generation
    private readonly Dictionary<string, string> _domainPatterns = new()
    {
        ["player"] = "Gaming customer or user account",
        ["deposit"] = "Money added to player account",
        ["withdrawal"] = "Money removed from player account",
        ["bet"] = "Wager placed by player",
        ["win"] = "Amount won by player",
        ["bonus"] = "Promotional credit given to player",
        ["game"] = "Casino game or slot machine",
        ["session"] = "Gaming session or login period",
        ["transaction"] = "Financial transaction",
        ["balance"] = "Account balance or available funds",
        ["currency"] = "Money denomination",
        ["country"] = "Geographic location",
        ["whitelabel"] = "Brand or operator",
        ["casino"] = "Casino gaming platform",
        ["sport"] = "Sports betting platform",
        ["live"] = "Live dealer games",
        ["bingo"] = "Bingo gaming platform"
    };

    public BusinessContextAutoGenerator(
        ISchemaService schemaService,
        IAIService aiService,
        ILogger<BusinessContextAutoGenerator> logger)
    {
        _schemaService = schemaService;
        _aiService = aiService;
        _logger = logger;
    }

    public async Task<List<AutoGeneratedTableContext>> GenerateTableContextsAsync()
    {
        return await GenerateTableContextsAsync(null);
    }

    public async Task<List<AutoGeneratedTableContext>> GenerateTableContextsAsync(Func<string, string, string?, Task>? progressCallback = null)
    {
        _logger.LogInformation("Starting auto-generation of table contexts");
        var results = new List<AutoGeneratedTableContext>();

        try
        {
            await progressCallback?.Invoke("Schema Loading", "Loading database schema...", null);

            var schema = await _schemaService.GetSchemaMetadataAsync();
            var processedTables = 0;

            foreach (var table in schema.Tables)
            {
                try
                {
                    await progressCallback?.Invoke("Table Processing", $"Processing table {table.Schema}.{table.Name} ({processedTables + 1}/{schema.Tables.Count})", table.Name);

                    var context = await GenerateTableContextAsync(table.Name, table.Schema, progressCallback);
                    results.Add(context);
                    _logger.LogDebug("Generated context for table {Schema}.{Table}", table.Schema, table.Name);
                    processedTables++;
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error generating context for table {Schema}.{Table}", table.Schema, table.Name);
                    processedTables++;
                }
            }

            _logger.LogInformation("Completed auto-generation for {Count} tables", results.Count);
            return results;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in GenerateTableContextsAsync");
            throw;
        }
    }

    public async Task<AutoGeneratedTableContext> GenerateTableContextAsync(string tableName, string schemaName)
    {
        return await GenerateTableContextAsync(tableName, schemaName, null);
    }

    public async Task<AutoGeneratedTableContext> GenerateTableContextAsync(string tableName, string schemaName, Func<string, string, string?, Task>? progressCallback = null)
    {
        _logger.LogDebug("Generating context for table {Schema}.{Table}", schemaName, tableName);

        try
        {
            await progressCallback?.Invoke("Table Analysis", $"Loading metadata for {schemaName}.{tableName}...", null);

            var tableMetadata = await _schemaService.GetTableMetadataAsync(tableName, schemaName);
            if (tableMetadata == null)
            {
                throw new ArgumentException($"Table {schemaName}.{tableName} not found");
            }

            await progressCallback?.Invoke("Table Analysis", $"Building AI prompt for {schemaName}.{tableName}...", null);

            // Build AI prompt for table analysis
            var prompt = BuildTableAnalysisPrompt(tableMetadata);

            await progressCallback?.Invoke("Table Analysis", $"Sending AI request for {schemaName}.{tableName}...", null);

            // Get AI analysis using the correct method for business context generation
            var aiResponse = await _aiService.GenerateInsightAsync(prompt, new object[0]);

            await progressCallback?.Invoke("Table Analysis", $"Parsing AI response for {schemaName}.{tableName}...", null);

            // Parse AI response and create context
            var context = ParseTableContextResponse(aiResponse, tableMetadata);

            await progressCallback?.Invoke("Column Analysis", $"Analyzing {tableMetadata.Columns.Count} columns...", null);

            // Generate column contexts with progress reporting
            context.Columns = await GenerateColumnContextsAsync(tableMetadata, progressCallback);

            await progressCallback?.Invoke("Relationship Analysis", $"Finding related tables for {schemaName}.{tableName}...", null);

            // Analyze relationships
            context.RelatedTables = await FindRelatedTablesAsync(tableMetadata);

            await progressCallback?.Invoke("Finalization", $"Calculating confidence score for {schemaName}.{tableName}...", null);

            // Calculate confidence score
            context.ConfidenceScore = CalculateTableConfidenceScore(context, tableMetadata);

            return context;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating context for table {Schema}.{Table}", schemaName, tableName);
            throw;
        }
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsAsync()
    {
        _logger.LogInformation("Starting auto-generation of glossary terms for all tables");
        var schema = await _schemaService.GetSchemaMetadataAsync();
        return await GenerateGlossaryTermsAsync(schema.Tables.Select(t => $"{t.Schema}.{t.Name}").ToList());
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsAsync(List<string> specificTables)
    {
        return await GenerateGlossaryTermsAsync(specificTables, null);
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsAsync(List<string> specificTables, Func<string, string, string?, Task>? progressCallback = null)
    {
        _logger.LogInformation("Starting auto-generation of glossary terms for {TableCount} specific tables", specificTables.Count);
        var results = new List<AutoGeneratedGlossaryTerm>();

        try
        {
            await progressCallback?.Invoke("Schema Loading", "Loading database schema...", null);

            var schema = await _schemaService.GetSchemaMetadataAsync();
            var allTerms = new HashSet<string>();

            // Filter tables based on specific selection
            var tablesToProcess = schema.Tables.Where(table =>
            {
                var fullTableName = $"{table.Schema}.{table.Name}";
                return specificTables.Contains(fullTableName);
            }).ToList();

            _logger.LogInformation("Processing {ProcessCount} tables out of {TotalCount} available tables",
                tablesToProcess.Count, schema.Tables.Count);

            await progressCallback?.Invoke("Term Extraction", $"Extracting terms from {tablesToProcess.Count} tables...", null);

            // Extract terms from selected table and column names only
            var processedTables = 0;
            foreach (var table in tablesToProcess)
            {
                _logger.LogDebug("Processing table {Schema}.{Table} for glossary terms", table.Schema, table.Name);

                await progressCallback?.Invoke("Term Extraction", $"Processing table {table.Schema}.{table.Name} ({processedTables + 1}/{tablesToProcess.Count})", table.Name);

                // Add table name terms
                var tableTerms = ExtractBusinessTerms(table.Name);
                foreach (var term in tableTerms)
                {
                    allTerms.Add(term.ToLowerInvariant());
                }

                // Add column name terms
                var processedColumns = 0;
                foreach (var column in table.Columns)
                {
                    await progressCallback?.Invoke("Column Processing", $"Processing column {column.Name} in {table.Name} ({processedColumns + 1}/{table.Columns.Count})", column.Name);

                    var columnTerms = ExtractBusinessTerms(column.Name);
                    foreach (var term in columnTerms)
                    {
                        allTerms.Add(term.ToLowerInvariant());
                    }
                    processedColumns++;
                }
                processedTables++;
            }

            _logger.LogInformation("Extracted {TermCount} unique terms from selected tables", allTerms.Count);

            await progressCallback?.Invoke("AI Generation", $"Generating definitions for {allTerms.Count} terms...", null);

            // Generate definitions for unique terms
            var processedTerms = 0;
            var validTerms = allTerms.Where(t => t.Length > 2).ToList();

            foreach (var term in validTerms)
            {
                try
                {
                    await progressCallback?.Invoke("AI Generation", $"Generating definition for '{term}' ({processedTerms + 1}/{validTerms.Count})", term);

                    var glossaryTerm = await GenerateGlossaryTermAsync(term, schema);
                    if (glossaryTerm.ConfidenceScore >= 0.6)
                    {
                        results.Add(glossaryTerm);
                    }
                    processedTerms++;
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Error generating glossary term for: {Term}", term);
                    processedTerms++;
                }
            }

            _logger.LogInformation("Generated {Count} glossary terms from {TableCount} selected tables", results.Count, tablesToProcess.Count);
            return results;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in GenerateGlossaryTermsAsync for specific tables");
            throw;
        }
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateColumnGlossaryAsync(string tableName, string schemaName)
    {
        var results = new List<AutoGeneratedGlossaryTerm>();

        try
        {
            var tableMetadata = await _schemaService.GetTableMetadataAsync(tableName, schemaName);
            if (tableMetadata == null) return results;

            var schema = await _schemaService.GetSchemaMetadataAsync();

            foreach (var column in tableMetadata.Columns)
            {
                var terms = ExtractBusinessTerms(column.Name);
                foreach (var term in terms.Where(t => t.Length > 2))
                {
                    var glossaryTerm = await GenerateGlossaryTermAsync(term, schema, tableName, column.Name);
                    if (glossaryTerm.ConfidenceScore >= 0.6)
                    {
                        results.Add(glossaryTerm);
                    }
                }
            }

            return results;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating column glossary for {Schema}.{Table}", schemaName, tableName);
            return results;
        }
    }

    public async Task<BusinessRelationshipAnalysis> AnalyzeTableRelationshipsAsync()
    {
        _logger.LogInformation("Starting table relationship analysis");

        try
        {
            var schema = await _schemaService.GetSchemaMetadataAsync();
            var analysis = new BusinessRelationshipAnalysis();

            // Analyze foreign key relationships
            analysis.Relationships = await AnalyzeForeignKeyRelationships(schema);

            // Identify business domains
            analysis.BusinessDomains = IdentifyBusinessDomains(schema);

            // Analyze data flows
            analysis.DataFlows = AnalyzeDataFlows(schema, analysis.Relationships);

            // Calculate overall confidence
            analysis.OverallConfidence = CalculateRelationshipConfidence(analysis);

            _logger.LogInformation("Completed relationship analysis with {RelCount} relationships, {DomainCount} domains",
                analysis.Relationships.Count, analysis.BusinessDomains.Count);

            return analysis;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in AnalyzeTableRelationshipsAsync");
            throw;
        }
    }

    private string BuildTableAnalysisPrompt(TableMetadata table)
    {
        var prompt = $@"
Analyze this database table and provide business context for a gaming/casino platform:

Table: {table.Schema}.{table.Name}
Columns: {string.Join(", ", table.Columns.Select(c => $"{c.Name} ({c.DataType})"))}

Based on the table and column names, provide:
1. Business Purpose: What is this table used for in business terms?
2. Business Context: How does this table fit into the overall business process?
3. Primary Use Case: What is the main business scenario this table supports?
4. Key Business Metrics: What important business metrics can be derived from this table?
5. Common Query Patterns: What types of business questions would this table help answer?
6. Business Rules: What business rules or constraints might apply to this data?

Focus on gaming/casino business terminology. Consider concepts like players, deposits, withdrawals, bets, wins, bonuses, games, sessions, etc.

Respond in JSON format:
{{
  ""businessPurpose"": ""..."",
  ""businessContext"": ""..."",
  ""primaryUseCase"": ""..."",
  ""keyBusinessMetrics"": [""...""],
  ""commonQueryPatterns"": [""...""],
  ""businessRules"": ""...""
}}";

        return prompt;
    }

    private AutoGeneratedTableContext ParseTableContextResponse(string aiResponse, TableMetadata table)
    {
        try
        {
            // Clean up the response to extract JSON
            var jsonMatch = Regex.Match(aiResponse, @"\{.*\}", RegexOptions.Singleline);
            if (!jsonMatch.Success)
            {
                throw new InvalidOperationException($"AI response does not contain valid JSON for table {table.Name}");
            }

            var jsonResponse = JsonSerializer.Deserialize<Dictionary<string, object>>(jsonMatch.Value);
            if (jsonResponse == null)
            {
                throw new InvalidOperationException($"Failed to parse AI response JSON for table {table.Name}");
            }

            return new AutoGeneratedTableContext
            {
                TableName = table.Name,
                SchemaName = table.Schema,
                BusinessPurpose = GetStringValue(jsonResponse, "businessPurpose"),
                BusinessContext = GetStringValue(jsonResponse, "businessContext"),
                PrimaryUseCase = GetStringValue(jsonResponse, "primaryUseCase"),
                KeyBusinessMetrics = GetStringArrayValue(jsonResponse, "keyBusinessMetrics"),
                CommonQueryPatterns = GetStringArrayValue(jsonResponse, "commonQueryPatterns"),
                BusinessRules = GetStringValue(jsonResponse, "businessRules"),
                GeneratedAt = DateTime.UtcNow,
                IsAutoGenerated = true
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error parsing AI response for table {Table}", table.Name);
            throw;
        }
    }

    private string BuildGlossaryTermPrompt(string term, SchemaMetadata schema, string? sourceTable = null, string? sourceColumn = null)
    {
        var prompt = new StringBuilder();

        prompt.AppendLine("You are a business analyst specializing in database schema analysis and business terminology.");
        prompt.AppendLine("Analyze the following business term and provide comprehensive business context.");
        prompt.AppendLine();
        prompt.AppendLine($"TERM TO ANALYZE: {term}");

        if (!string.IsNullOrEmpty(sourceTable))
        {
            prompt.AppendLine($"SOURCE TABLE: {sourceTable}");
        }

        if (!string.IsNullOrEmpty(sourceColumn))
        {
            prompt.AppendLine($"SOURCE COLUMN: {sourceColumn}");
        }

        prompt.AppendLine();
        prompt.AppendLine("CONTEXT - Database Schema Information:");

        // Add relevant table information
        var relevantTables = schema.Tables.Where(t =>
            t.Name.ToLowerInvariant().Contains(term.ToLowerInvariant()) ||
            t.Columns.Any(c => c.Name.ToLowerInvariant().Contains(term.ToLowerInvariant())) ||
            (!string.IsNullOrEmpty(sourceTable) && t.Name.Equals(sourceTable, StringComparison.OrdinalIgnoreCase))
        ).Take(3);

        foreach (var table in relevantTables)
        {
            prompt.AppendLine($"Table: {table.Schema}.{table.Name}");
            var relevantColumns = table.Columns.Where(c =>
                c.Name.ToLowerInvariant().Contains(term.ToLowerInvariant()) ||
                (!string.IsNullOrEmpty(sourceColumn) && c.Name.Equals(sourceColumn, StringComparison.OrdinalIgnoreCase))
            ).Take(5);

            foreach (var col in relevantColumns)
            {
                prompt.AppendLine($"  - {col.Name} ({col.DataType}){(col.IsPrimaryKey ? " [PK]" : "")}{(col.IsForeignKey ? " [FK]" : "")}");
            }
        }

        prompt.AppendLine();
        prompt.AppendLine("INSTRUCTIONS:");
        prompt.AppendLine("Provide a JSON response with the following structure:");
        prompt.AppendLine("{");
        prompt.AppendLine("  \"definition\": \"Clear, concise business definition of the term\",");
        prompt.AppendLine("  \"businessContext\": \"How this term is used in business operations\",");
        prompt.AppendLine("  \"category\": \"Business category (e.g., Financial, Geographic, Identifier, etc.)\",");
        prompt.AppendLine("  \"synonyms\": [\"list\", \"of\", \"alternative\", \"terms\"],");
        prompt.AppendLine("  \"relatedTerms\": [\"list\", \"of\", \"related\", \"business\", \"terms\"],");
        prompt.AppendLine("  \"confidenceScore\": 0.85");
        prompt.AppendLine("}");
        prompt.AppendLine();
        prompt.AppendLine("Focus on business meaning rather than technical implementation.");
        prompt.AppendLine("Consider the gaming/casino industry context if applicable.");

        return prompt.ToString();
    }

    private AutoGeneratedGlossaryTerm ParseGlossaryTermResponse(string aiResponse, string term, string? sourceTable = null, string? sourceColumn = null)
    {
        try
        {
            // Clean up the response to extract JSON
            var jsonMatch = Regex.Match(aiResponse, @"\{.*\}", RegexOptions.Singleline);
            if (!jsonMatch.Success)
            {
                throw new InvalidOperationException($"AI response does not contain valid JSON for term {term}");
            }

            var jsonResponse = JsonSerializer.Deserialize<Dictionary<string, object>>(jsonMatch.Value);
            if (jsonResponse == null)
            {
                throw new InvalidOperationException($"Failed to parse AI response JSON for term {term}");
            }

            return new AutoGeneratedGlossaryTerm
            {
                Term = term,
                Definition = GetStringValue(jsonResponse, "definition"),
                BusinessContext = GetStringValue(jsonResponse, "businessContext"),
                Category = GetStringValue(jsonResponse, "category"),
                Synonyms = GetStringArrayValue(jsonResponse, "synonyms"),
                RelatedTerms = GetStringArrayValue(jsonResponse, "relatedTerms"),
                ConfidenceScore = GetDoubleValue(jsonResponse, "confidenceScore", 0.7),
                GeneratedAt = DateTime.UtcNow,
                IsAutoGenerated = true,
                SourceTables = !string.IsNullOrEmpty(sourceTable) ? new List<string> { sourceTable } : new List<string>(),
                SourceColumns = !string.IsNullOrEmpty(sourceColumn) ? new List<string> { sourceColumn } : new List<string>()
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error parsing AI response for glossary term {Term}", term);
            throw;
        }
    }

    private async Task<List<AutoGeneratedColumnContext>> GenerateColumnContextsAsync(TableMetadata table)
    {
        return await GenerateColumnContextsAsync(table, null);
    }

    private async Task<List<AutoGeneratedColumnContext>> GenerateColumnContextsAsync(TableMetadata table, Func<string, string, string?, Task>? progressCallback = null)
    {
        var results = new List<AutoGeneratedColumnContext>();
        var processedColumns = 0;

        foreach (var column in table.Columns)
        {
            await progressCallback?.Invoke("Column Analysis", $"Processing column {column.Name} ({processedColumns + 1}/{table.Columns.Count})", column.Name);

            var context = new AutoGeneratedColumnContext
            {
                ColumnName = column.Name,
                BusinessName = GenerateBusinessName(column.Name),
                BusinessDescription = GenerateColumnDescription(column, table.Name),
                DataType = column.DataType,
                BusinessDataType = MapToBusinessDataType(column.DataType),
                IsPrimaryKey = column.IsPrimaryKey,
                IsForeignKey = column.IsForeignKey,
                ConfidenceScore = CalculateColumnConfidenceScore(column),
                IsAutoGenerated = true
            };

            // Add business rules based on column patterns
            context.BusinessRules = GenerateColumnBusinessRules(column);
            context.CommonUseCases = GenerateColumnUseCases(column, table.Name);

            results.Add(context);
            processedColumns++;
        }

        return results;
    }

    private async Task<List<string>> FindRelatedTablesAsync(TableMetadata table)
    {
        var relatedTables = new List<string>();

        try
        {
            var schema = await _schemaService.GetSchemaMetadataAsync();

            // Find tables with similar naming patterns
            var tableNameParts = ExtractBusinessTerms(table.Name);

            foreach (var otherTable in schema.Tables.Where(t => t.Name != table.Name))
            {
                var otherNameParts = ExtractBusinessTerms(otherTable.Name);
                var commonTerms = tableNameParts.Intersect(otherNameParts, StringComparer.OrdinalIgnoreCase).Count();

                if (commonTerms > 0)
                {
                    relatedTables.Add($"{otherTable.Schema}.{otherTable.Name}");
                }
            }

            // Find tables with foreign key relationships
            foreach (var column in table.Columns.Where(c => c.IsForeignKey))
            {
                // Simple heuristic: look for tables with similar column names
                var potentialReferences = schema.Tables
                    .Where(t => t.Columns.Any(c => c.Name.Equals(column.Name, StringComparison.OrdinalIgnoreCase) && c.IsPrimaryKey))
                    .Select(t => $"{t.Schema}.{t.Name}")
                    .ToList();

                relatedTables.AddRange(potentialReferences);
            }

            return relatedTables.Distinct().ToList();
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error finding related tables for {Table}", table.Name);
            return relatedTables;
        }
    }

    private async Task<AutoGeneratedGlossaryTerm> GenerateGlossaryTermAsync(string term, SchemaMetadata schema, string? sourceTable = null, string? sourceColumn = null)
    {
        try
        {
            _logger.LogDebug("Generating AI-powered glossary term for: {Term}", term);

            // Build AI prompt for glossary term analysis
            var prompt = BuildGlossaryTermPrompt(term, schema, sourceTable, sourceColumn);

            // Get AI analysis using the correct method for business context generation
            var aiResponse = await _aiService.GenerateInsightAsync(prompt, new object[0]);

            // Parse AI response
            var glossaryTerm = ParseGlossaryTermResponse(aiResponse, term, sourceTable, sourceColumn);

            _logger.LogDebug("Generated AI glossary term for {Term} with confidence {Confidence}",
                term, glossaryTerm.ConfidenceScore);

            return glossaryTerm;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating AI glossary term for: {Term}", term);

            // Fallback to basic term generation
            return new AutoGeneratedGlossaryTerm
            {
                Term = term,
                Definition = $"Business term: {term}",
                BusinessContext = $"Context for {term} in business operations",
                Synonyms = new List<string>(),
                RelatedTerms = new List<string>(),
                Category = "Business",
                ConfidenceScore = 0.3,
                GeneratedAt = DateTime.UtcNow,
                IsAutoGenerated = true,
                SourceTables = !string.IsNullOrEmpty(sourceTable) ? new List<string> { sourceTable } : new List<string>(),
                SourceColumns = !string.IsNullOrEmpty(sourceColumn) ? new List<string> { sourceColumn } : new List<string>()
            };
        }
    }

    private async Task<List<TableRelationship>> AnalyzeForeignKeyRelationships(SchemaMetadata schema)
    {
        var relationships = new List<TableRelationship>();

        foreach (var table in schema.Tables)
        {
            foreach (var column in table.Columns.Where(c => c.IsForeignKey))
            {
                // Find potential referenced tables
                var referencedTables = schema.Tables
                    .Where(t => t.Columns.Any(c => c.Name.Equals(column.Name, StringComparison.OrdinalIgnoreCase) && c.IsPrimaryKey))
                    .ToList();

                foreach (var referencedTable in referencedTables)
                {
                    var relationship = new TableRelationship
                    {
                        FromTable = table.Name,
                        FromSchema = table.Schema,
                        ToTable = referencedTable.Name,
                        ToSchema = referencedTable.Schema,
                        RelationshipType = "ManyToOne",
                        BusinessRelationship = GenerateBusinessRelationship(table.Name, referencedTable.Name),
                        ColumnMappings = new List<ColumnMapping>
                        {
                            new ColumnMapping
                            {
                                FromColumn = column.Name,
                                ToColumn = column.Name,
                                BusinessMeaning = GenerateColumnRelationshipMeaning(column.Name, table.Name, referencedTable.Name)
                            }
                        },
                        ConfidenceScore = 0.8
                    };

                    relationships.Add(relationship);
                }
            }
        }

        return relationships;
    }

    private List<BusinessDomain> IdentifyBusinessDomains(SchemaMetadata schema)
    {
        var domains = new List<BusinessDomain>();

        // Gaming domain patterns
        var gamingPatterns = new Dictionary<string, List<string>>
        {
            ["Player Management"] = new() { "player", "user", "account", "profile" },
            ["Financial Transactions"] = new() { "deposit", "withdrawal", "transaction", "payment", "balance" },
            ["Gaming Activity"] = new() { "bet", "win", "game", "session", "play" },
            ["Bonus System"] = new() { "bonus", "promotion", "reward", "campaign" },
            ["Platform Management"] = new() { "whitelabel", "brand", "operator", "config" },
            ["Geographic Data"] = new() { "country", "region", "currency", "locale" }
        };

        foreach (var pattern in gamingPatterns)
        {
            var matchingTables = schema.Tables
                .Where(t => pattern.Value.Any(keyword =>
                    t.Name.ToLowerInvariant().Contains(keyword) ||
                    t.Columns.Any(c => c.Name.ToLowerInvariant().Contains(keyword))))
                .Select(t => $"{t.Schema}.{t.Name}")
                .ToList();

            if (matchingTables.Any())
            {
                domains.Add(new BusinessDomain
                {
                    DomainName = pattern.Key,
                    Description = $"Tables related to {pattern.Key.ToLowerInvariant()} in the gaming platform",
                    Tables = matchingTables,
                    KeyConcepts = pattern.Value,
                    ConfidenceScore = 0.7
                });
            }
        }

        return domains;
    }

    private List<DataFlow> AnalyzeDataFlows(SchemaMetadata schema, List<TableRelationship> relationships)
    {
        var dataFlows = new List<DataFlow>();

        // Common gaming data flows
        var commonFlows = new Dictionary<string, (string process, List<string> sequence)>
        {
            ["Player Registration"] = ("New player onboarding", new() { "players", "accounts", "profiles" }),
            ["Deposit Process"] = ("Player funding account", new() { "players", "transactions", "balances" }),
            ["Gaming Session"] = ("Player gaming activity", new() { "sessions", "bets", "games", "wins" }),
            ["Withdrawal Process"] = ("Player cashing out", new() { "balances", "withdrawals", "transactions" }),
            ["Bonus Allocation"] = ("Bonus distribution", new() { "bonuses", "players", "balances" })
        };

        foreach (var flow in commonFlows)
        {
            var matchingTables = new List<string>();

            foreach (var tablePattern in flow.Value.sequence)
            {
                var matches = schema.Tables
                    .Where(t => t.Name.ToLowerInvariant().Contains(tablePattern))
                    .Select(t => $"{t.Schema}.{t.Name}")
                    .ToList();

                matchingTables.AddRange(matches);
            }

            if (matchingTables.Count >= 2)
            {
                dataFlows.Add(new DataFlow
                {
                    FlowName = flow.Key,
                    BusinessProcess = flow.Value.process,
                    TableSequence = matchingTables.Distinct().ToList(),
                    Description = $"Data flow for {flow.Value.process} involving {matchingTables.Count} tables",
                    ConfidenceScore = 0.6
                });
            }
        }

        return dataFlows;
    }

    // Helper methods for business context generation
    private string GenerateBusinessName(string technicalName)
    {
        // Convert technical names to business-friendly names
        var name = technicalName.Replace("tbl_", "").Replace("_", " ");

        // Apply domain-specific transformations
        foreach (var pattern in _domainPatterns)
        {
            if (name.ToLowerInvariant().Contains(pattern.Key))
            {
                name = name.Replace(pattern.Key, pattern.Value, StringComparison.OrdinalIgnoreCase);
            }
        }

        return System.Globalization.CultureInfo.CurrentCulture.TextInfo.ToTitleCase(name.ToLowerInvariant());
    }

    private string GenerateColumnDescription(ColumnMetadata column, string tableName)
    {
        var businessName = GenerateBusinessName(column.Name);
        var tableBusinessName = GenerateBusinessName(tableName);

        if (column.IsPrimaryKey)
        {
            return $"Unique identifier for {tableBusinessName}";
        }

        if (column.IsForeignKey)
        {
            return $"Reference to related {businessName} record";
        }

        // Check for common patterns
        var lowerName = column.Name.ToLowerInvariant();
        if (lowerName.Contains("date") || lowerName.Contains("time"))
        {
            return $"Date/time when {businessName} occurred";
        }

        if (lowerName.Contains("amount") || lowerName.Contains("value"))
        {
            return $"Monetary amount for {businessName}";
        }

        if (lowerName.Contains("count") || lowerName.Contains("number"))
        {
            return $"Count or number of {businessName}";
        }

        return $"{businessName} information for {tableBusinessName}";
    }

    private string MapToBusinessDataType(string technicalDataType)
    {
        return technicalDataType.ToLowerInvariant() switch
        {
            var t when t.Contains("varchar") || t.Contains("char") || t.Contains("text") => "Text",
            var t when t.Contains("int") || t.Contains("bigint") => "Number",
            var t when t.Contains("decimal") || t.Contains("money") || t.Contains("float") => "Currency/Decimal",
            var t when t.Contains("date") || t.Contains("time") => "Date/Time",
            var t when t.Contains("bit") || t.Contains("bool") => "Yes/No",
            var t when t.Contains("uniqueidentifier") => "Unique ID",
            _ => "Data"
        };
    }

    private List<string> GenerateColumnBusinessRules(ColumnMetadata column)
    {
        var rules = new List<string>();

        if (!column.IsNullable)
        {
            rules.Add("Required field - cannot be empty");
        }

        if (column.IsPrimaryKey)
        {
            rules.Add("Must be unique across all records");
        }

        var lowerName = column.Name.ToLowerInvariant();
        if (lowerName.Contains("email"))
        {
            rules.Add("Must be valid email format");
        }

        if (lowerName.Contains("amount") || lowerName.Contains("balance"))
        {
            rules.Add("Must be non-negative value");
        }

        if (lowerName.Contains("date"))
        {
            rules.Add("Must be valid date");
        }

        return rules;
    }

    private List<string> GenerateColumnUseCases(ColumnMetadata column, string tableName)
    {
        var useCases = new List<string>();
        var businessName = GenerateBusinessName(column.Name);
        var tableBusinessName = GenerateBusinessName(tableName);

        useCases.Add($"Filter {tableBusinessName} by {businessName}");
        useCases.Add($"Sort {tableBusinessName} by {businessName}");

        var lowerName = column.Name.ToLowerInvariant();
        if (lowerName.Contains("amount") || lowerName.Contains("value"))
        {
            useCases.Add($"Calculate total {businessName}");
            useCases.Add($"Calculate average {businessName}");
        }

        if (lowerName.Contains("date"))
        {
            useCases.Add($"Group by {businessName} period");
            useCases.Add($"Filter by {businessName} range");
        }

        if (lowerName.Contains("count"))
        {
            useCases.Add($"Sum total {businessName}");
        }

        return useCases;
    }

    private List<string> ExtractBusinessTerms(string name)
    {
        // Split on common separators and extract meaningful terms
        var terms = new List<string>();
        var cleanName = name.Replace("tbl_", "").Replace("_", " ");

        // Split on various separators
        var parts = Regex.Split(cleanName, @"[_\s\-\.]+", RegexOptions.IgnoreCase)
            .Where(p => !string.IsNullOrWhiteSpace(p) && p.Length > 1)
            .ToList();

        terms.AddRange(parts);

        // Also try camelCase splitting
        var camelCaseParts = Regex.Split(name, @"(?<!^)(?=[A-Z])", RegexOptions.IgnoreCase)
            .Where(p => !string.IsNullOrWhiteSpace(p) && p.Length > 1)
            .ToList();

        terms.AddRange(camelCaseParts);

        return terms.Distinct(StringComparer.OrdinalIgnoreCase).ToList();
    }















    private string GenerateBusinessRelationship(string fromTable, string toTable)
    {
        var fromBusiness = GenerateBusinessName(fromTable);
        var toBusiness = GenerateBusinessName(toTable);
        return $"{fromBusiness} is related to {toBusiness}";
    }

    private string GenerateColumnRelationshipMeaning(string columnName, string fromTable, string toTable)
    {
        var columnBusiness = GenerateBusinessName(columnName);
        var fromBusiness = GenerateBusinessName(fromTable);
        var toBusiness = GenerateBusinessName(toTable);
        return $"{columnBusiness} links {fromBusiness} to {toBusiness}";
    }

    // Confidence calculation methods
    private double CalculateTableConfidenceScore(AutoGeneratedTableContext context, TableMetadata table)
    {
        double score = 0.5; // Base score

        // Increase confidence based on recognizable patterns
        var lowerTableName = table.Name.ToLowerInvariant();
        foreach (var pattern in _domainPatterns.Keys)
        {
            if (lowerTableName.Contains(pattern))
            {
                score += 0.1;
            }
        }

        // Increase confidence based on column patterns
        var recognizedColumns = table.Columns.Count(c =>
            _domainPatterns.Keys.Any(p => c.Name.ToLowerInvariant().Contains(p)));

        score += (double)recognizedColumns / table.Columns.Count * 0.3;

        // Cap at 0.9 for auto-generated content
        return Math.Min(score, 0.9);
    }

    private double CalculateColumnConfidenceScore(ColumnMetadata column)
    {
        double score = 0.5; // Base score

        var lowerName = column.Name.ToLowerInvariant();

        // Increase confidence for recognized patterns
        foreach (var pattern in _domainPatterns.Keys)
        {
            if (lowerName.Contains(pattern))
            {
                score += 0.2;
                break;
            }
        }

        // Increase confidence for standard patterns
        if (lowerName.Contains("id") || column.IsPrimaryKey || column.IsForeignKey)
            score += 0.1;

        if (lowerName.Contains("date") || lowerName.Contains("time"))
            score += 0.1;

        if (lowerName.Contains("amount") || lowerName.Contains("value"))
            score += 0.1;

        return Math.Min(score, 0.9);
    }



    private double CalculateRelationshipConfidence(BusinessRelationshipAnalysis analysis)
    {
        if (!analysis.Relationships.Any())
            return 0.3;

        var avgRelationshipConfidence = analysis.Relationships.Average(r => r.ConfidenceScore);
        var avgDomainConfidence = analysis.BusinessDomains.Any()
            ? analysis.BusinessDomains.Average(d => d.ConfidenceScore)
            : 0.5;

        return (avgRelationshipConfidence + avgDomainConfidence) / 2;
    }

    // Utility methods for parsing AI responses
    private string GetStringValue(Dictionary<string, object> dict, string key)
    {
        if (dict.TryGetValue(key, out var value))
        {
            return value?.ToString() ?? string.Empty;
        }
        return string.Empty;
    }

    private List<string> GetStringArrayValue(Dictionary<string, object> dict, string key)
    {
        if (dict.TryGetValue(key, out var value))
        {
            if (value is JsonElement element && element.ValueKind == JsonValueKind.Array)
            {
                return element.EnumerateArray()
                    .Select(e => e.GetString() ?? string.Empty)
                    .Where(s => !string.IsNullOrEmpty(s))
                    .ToList();
            }
        }
        return new List<string>();
    }

    private double GetDoubleValue(Dictionary<string, object> dict, string key, double defaultValue = 0.0)
    {
        if (dict.TryGetValue(key, out var value))
        {
            if (value is JsonElement element && element.ValueKind == JsonValueKind.Number)
            {
                return element.GetDouble();
            }
            if (double.TryParse(value?.ToString(), out var doubleValue))
            {
                return doubleValue;
            }
        }
        return defaultValue;
    }
}
