using BIReportingCopilot.Core.Interfaces;
using BIReportingCopilot.Core.Interfaces.AI;
using BIReportingCopilot.Core.Interfaces.Schema;
using BIReportingCopilot.Core.Models;
using Microsoft.Extensions.Logging;
using System.Text.RegularExpressions;

namespace BIReportingCopilot.Infrastructure.AI.Management;

/// <summary>
/// Handles glossary term generation using AI services
/// </summary>
public class GlossaryTermGenerator
{
    private readonly ISchemaService _schemaService;
    private readonly IAIService _aiService;
    private readonly ILogger<GlossaryTermGenerator> _logger;
    private readonly AIServiceHelper _aiServiceHelper;

    public GlossaryTermGenerator(
        ISchemaService schemaService,
        IAIService aiService,
        ILogger<GlossaryTermGenerator> logger,
        AIServiceHelper aiServiceHelper)
    {
        _schemaService = schemaService;
        _aiService = aiService;
        _logger = logger;
        _aiServiceHelper = aiServiceHelper;
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsAsync()
    {
        _logger.LogInformation("Starting auto-generation of glossary terms for all tables");
        var schema = await _schemaService.GetSchemaMetadataAsync();
        return await GenerateGlossaryTermsAsync(schema.Tables.Select(t => $"{t.Schema}.{t.Name}").ToList());
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsAsync(
        List<string>? specificTables = null, 
        Func<string, string, string?, Task>? progressCallback = null, 
        bool mockMode = false)
    {
        // Handle null case - if no specific tables provided, generate for all tables
        if (specificTables == null)
        {
            return await GenerateGlossaryTermsAsync();
        }

        _logger.LogInformation("Starting auto-generation of glossary terms for {TableCount} specific tables (MockMode: {MockMode})", specificTables.Count, mockMode);
        var results = new List<AutoGeneratedGlossaryTerm>();

        try
        {
            if (progressCallback != null)
                await progressCallback("Schema Loading", "Loading database schema...", null);

            var schema = await _schemaService.GetSchemaMetadataAsync();
            var allTerms = new HashSet<string>();

            // Filter tables based on specific selection
            var tablesToProcess = schema.Tables.Where(table =>
            {
                var fullTableName = $"{table.Schema}.{table.Name}";
                return specificTables.Contains(fullTableName);
            }).ToList();

            _logger.LogInformation("Processing {ProcessCount} tables out of {TotalCount} available tables",
                tablesToProcess.Count, schema.Tables.Count);

            if (progressCallback != null)
                await progressCallback("Term Extraction", $"Extracting terms from {tablesToProcess.Count} tables...", null);

            // Extract terms from selected table and column names only
            var processedTables = 0;
            foreach (var table in tablesToProcess)
            {
                _logger.LogDebug("Processing table {Schema}.{Table} for glossary terms", table.Schema, table.Name);

                if (progressCallback != null)
                    await progressCallback("Term Extraction", $"Processing table {table.Schema}.{table.Name} ({processedTables + 1}/{tablesToProcess.Count})", table.Name);

                // Add table name terms
                var tableTerms = ExtractBusinessTerms(table.Name);
                foreach (var term in tableTerms)
                {
                    allTerms.Add(term.ToLowerInvariant());
                }

                // Add column name terms
                var processedColumns = 0;
                foreach (var column in table.Columns)
                {
                    if (progressCallback != null)
                        await progressCallback("Column Processing", $"Processing column {column.Name} in {table.Name} ({processedColumns + 1}/{table.Columns.Count})", column.Name);

                    var columnTerms = ExtractBusinessTerms(column.Name);
                    foreach (var term in columnTerms)
                    {
                        allTerms.Add(term.ToLowerInvariant());
                    }
                    processedColumns++;
                }
                processedTables++;
            }

            _logger.LogInformation("Extracted {TermCount} unique terms from selected tables", allTerms.Count);

            if (progressCallback != null)
                await progressCallback("AI Generation", $"Generating definitions for {allTerms.Count} terms...", null);

            // Generate definitions for unique terms (limit to prevent infinite loops)
            var processedTerms = 0;
            var validTerms = allTerms.Where(t => t.Length > 2 && t.Length <= 50).Take(20).ToList(); // Limit to 20 terms max

            _logger.LogInformation("Processing {Count} glossary terms (limited from {Total} total terms)", validTerms.Count, allTerms.Count);

            foreach (var term in validTerms)
            {
                try
                {
                    if (progressCallback != null)
                        await progressCallback("AI Generation", $"Generating definition for '{term}' ({processedTerms + 1}/{validTerms.Count})", term);

                    AutoGeneratedGlossaryTerm glossaryTerm;
                    if (mockMode)
                    {
                        if (progressCallback != null)
                            await progressCallback("AI Generation", $"Analyzing term '{term}' (mock mode)...", term);
                        await Task.Delay(100);
                        if (progressCallback != null)
                            await progressCallback("AI Generation", $"Generating mock definition for '{term}'...", term);
                        await Task.Delay(100);

                        glossaryTerm = MockDataGenerator.GenerateMockGlossaryTerm(term);

                        if (progressCallback != null)
                            await progressCallback("AI Generation", $"Mock definition completed for '{term}'", term);
                        await Task.Delay(50);
                    }
                    else
                    {
                        // Skip problematic compound terms that are too long or complex
                        if (term.Length > 30 || term.ToLowerInvariant().Contains("promotionalsports"))
                        {
                            _logger.LogDebug("Skipping complex term: {Term}", term);
                            processedTerms++;
                            continue;
                        }

                        glossaryTerm = await GenerateGlossaryTermAsync(term, schema);
                    }

                    if (glossaryTerm.ConfidenceScore >= 0.6)
                    {
                        results.Add(glossaryTerm);
                    }
                    processedTerms++;
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Error generating glossary term for: {Term}. Skipping...", term);
                    processedTerms++;
                    // Continue processing other terms instead of failing
                }
            }

            _logger.LogInformation("Generated {Count} glossary terms from {TableCount} selected tables", results.Count, tablesToProcess.Count);
            return results;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in GenerateGlossaryTermsAsync for specific tables");
            throw;
        }
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateColumnGlossaryAsync(string tableName, string schemaName)
    {
        var results = new List<AutoGeneratedGlossaryTerm>();

        try
        {
            var tableMetadata = await _schemaService.GetTableMetadataAsync(tableName, schemaName);
            if (tableMetadata == null) return results;

            var schema = await _schemaService.GetSchemaMetadataAsync();

            foreach (var column in tableMetadata.Columns)
            {
                var terms = ExtractBusinessTerms(column.Name);
                foreach (var term in terms.Where(t => t.Length > 2))
                {
                    var glossaryTerm = await GenerateGlossaryTermAsync(term, schema, tableName, column.Name);
                    if (glossaryTerm.ConfidenceScore >= 0.6)
                    {
                        results.Add(glossaryTerm);
                    }
                }
            }

            return results;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating column glossary for {Schema}.{Table}", schemaName, tableName);
            return results;
        }
    }

    private async Task<AutoGeneratedGlossaryTerm> GenerateGlossaryTermAsync(string term, SchemaMetadata schema, string? tableName = null, string? columnName = null)
    {
        try
        {
            _logger.LogDebug("Generating glossary term for: {Term}", term);

            var prompt = BuildGlossaryPrompt(term, schema, tableName, columnName);
            var aiResponse = await _aiServiceHelper.GenerateStructuredResponseAsync(prompt);

            return ParseGlossaryResponse(aiResponse, term);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating glossary term for: {Term}", term);
            return MockDataGenerator.GenerateMockGlossaryTerm(term);
        }
    }

    private string BuildGlossaryPrompt(string term, SchemaMetadata schema, string? tableName = null, string? columnName = null)
    {
        var context = tableName != null && columnName != null 
            ? $"This term appears as column '{columnName}' in table '{tableName}'."
            : "This term appears in the database schema.";

        var prompt = $@"
Define this business term for a gaming/casino platform database:

Term: {term}
Context: {context}

Provide a clear, concise business definition that would be understood by business users.
Focus on gaming/casino terminology like players, deposits, withdrawals, bets, wins, bonuses, games, sessions, etc.

Consider these related tables in the schema: {string.Join(", ", schema.Tables.Take(5).Select(t => t.Name))}

Respond in JSON format:
{{
  ""term"": ""{term}"",
  ""definition"": ""Clear business definition..."",
  ""businessContext"": ""How this relates to business operations..."",
  ""category"": ""Gaming/Financial/Customer/etc"",
  ""tags"": [""tag1"", ""tag2""],
  ""confidenceScore"": 0.85
}}";

        return prompt;
    }

    private AutoGeneratedGlossaryTerm ParseGlossaryResponse(string aiResponse, string term)
    {
        try
        {
            _logger.LogDebug("🤖 AI Response for term {Term}: {Response}", term, aiResponse);

            // Try to extract JSON from the response
            var jsonMatch = Regex.Match(aiResponse, @"\{.*\}", RegexOptions.Singleline);
            if (!jsonMatch.Success)
            {
                _logger.LogWarning("⚠️ AI response does not contain valid JSON for term {Term}. Falling back to mock data.", term);
                return MockDataGenerator.GenerateMockGlossaryTerm(term);
            }

            var jsonString = jsonMatch.Value;
            var jsonResponse = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, object>>(jsonString);
            if (jsonResponse == null)
            {
                _logger.LogWarning("⚠️ Failed to parse AI response JSON for term {Term}. Falling back to mock data.", term);
                return MockDataGenerator.GenerateMockGlossaryTerm(term);
            }

            return new AutoGeneratedGlossaryTerm
            {
                Term = JsonHelper.GetStringValue(jsonResponse, "term") ?? term,
                Definition = JsonHelper.GetStringValue(jsonResponse, "definition") ?? $"Definition for {term}",
                BusinessContext = JsonHelper.GetStringValue(jsonResponse, "businessContext") ?? "Business context not available",
                Category = JsonHelper.GetStringValue(jsonResponse, "category") ?? "General",
                Tags = JsonHelper.GetStringArrayValue(jsonResponse, "tags"),
                ConfidenceScore = JsonHelper.GetDoubleValue(jsonResponse, "confidenceScore", 0.7),
                GeneratedAt = DateTime.UtcNow,
                IsAutoGenerated = true
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error parsing glossary response for term: {Term}", term);
            return MockDataGenerator.GenerateMockGlossaryTerm(term);
        }
    }

    private List<string> ExtractBusinessTerms(string input)
    {
        var terms = new List<string>();

        // Split on common separators and camelCase
        var words = Regex.Split(input, @"[_\-\s]+|(?=[A-Z])")
            .Where(w => !string.IsNullOrWhiteSpace(w) && w.Length > 1)
            .Select(w => w.ToLowerInvariant())
            .ToList();

        // Add individual words
        terms.AddRange(words);

        // Add compound terms for meaningful combinations
        if (words.Count > 1)
        {
            // Add pairs of words
            for (int i = 0; i < words.Count - 1; i++)
            {
                var compound = $"{words[i]}{words[i + 1]}";
                if (compound.Length <= 30) // Avoid overly long compounds
                {
                    terms.Add(compound);
                }
            }
        }

        return terms.Distinct().ToList();
    }
}
