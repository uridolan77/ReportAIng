using BIReportingCopilot.Core.Interfaces;
using BIReportingCopilot.Core.Interfaces.AI;
using BIReportingCopilot.Core.Interfaces.Schema;
using BIReportingCopilot.Core.Models;
using Microsoft.Extensions.Logging;
using System.Text.Json;
using System.Text.RegularExpressions;

namespace BIReportingCopilot.Infrastructure.AI.Management;

/// <summary>
/// Handles table context generation using AI services
/// </summary>
public class TableContextGenerator
{
    private readonly ISchemaService _schemaService;
    private readonly IAIService _aiService;
    private readonly ILogger<TableContextGenerator> _logger;
    private readonly AIServiceHelper _aiServiceHelper;

    // Gaming/Casino domain knowledge for better context generation
    private readonly Dictionary<string, string> _domainPatterns = new()
    {
        ["player"] = "Gaming customer or user account",
        ["deposit"] = "Money added to player account",
        ["withdrawal"] = "Money removed from player account",
        ["bet"] = "Wager placed by player",
        ["win"] = "Amount won by player",
        ["bonus"] = "Promotional credit given to player",
        ["game"] = "Casino game or slot machine",
        ["session"] = "Gaming session or login period",
        ["transaction"] = "Financial transaction",
        ["balance"] = "Account balance or available funds",
        ["currency"] = "Money denomination",
        ["country"] = "Geographic location",
        ["whitelabel"] = "Brand or operator",
        ["casino"] = "Casino gaming platform",
        ["sport"] = "Sports betting platform",
        ["live"] = "Live dealer games",
        ["bingo"] = "Bingo gaming platform"
    };

    public TableContextGenerator(
        ISchemaService schemaService,
        IAIService aiService,
        ILogger<TableContextGenerator> logger,
        AIServiceHelper aiServiceHelper)
    {
        _schemaService = schemaService;
        _aiService = aiService;
        _logger = logger;
        _aiServiceHelper = aiServiceHelper;
    }

    public async Task<List<AutoGeneratedTableContext>> GenerateTableContextsAsync(
        Func<string, string, string?, Task>? progressCallback = null)
    {
        _logger.LogInformation("Starting auto-generation of table contexts");
        var results = new List<AutoGeneratedTableContext>();

        try
        {
            if (progressCallback != null)
                await progressCallback("Schema Loading", "Loading database schema...", null);

            var schema = await _schemaService.GetSchemaMetadataAsync();
            var processedTables = 0;

            foreach (var table in schema.Tables)
            {
                try
                {
                    if (progressCallback != null)
                        await progressCallback("Table Processing", $"Processing table {table.Schema}.{table.Name} ({processedTables + 1}/{schema.Tables.Count})", table.Name);

                    var context = await GenerateTableContextAsync(table.Name, table.Schema, progressCallback);
                    results.Add(context);
                    _logger.LogDebug("Generated context for table {Schema}.{Table}", table.Schema, table.Name);
                    processedTables++;
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error generating context for table {Schema}.{Table}", table.Schema, table.Name);
                    processedTables++;
                }
            }

            _logger.LogInformation("Completed auto-generation for {Count} tables", results.Count);
            return results;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in GenerateTableContextsAsync");
            throw;
        }
    }

    public async Task<AutoGeneratedTableContext> GenerateTableContextAsync(
        string tableName, 
        string schemaName, 
        Func<string, string, string?, Task>? progressCallback = null, 
        bool mockMode = false)
    {
        _logger.LogDebug("Generating context for table {Schema}.{Table} (MockMode: {MockMode})", schemaName, tableName, mockMode);

        try
        {
            if (progressCallback != null)
                await progressCallback("Table Analysis", $"Loading metadata for {schemaName}.{tableName}...", null);

            var tableMetadata = await _schemaService.GetTableMetadataAsync(tableName, schemaName);
            if (tableMetadata == null)
            {
                throw new ArgumentException($"Table {schemaName}.{tableName} not found");
            }

            if (progressCallback != null)
                await progressCallback("Table Analysis", $"Building AI prompt for {schemaName}.{tableName}...", null);

            // Build AI prompt for table analysis
            var prompt = BuildTableAnalysisPrompt(tableMetadata);

            AutoGeneratedTableContext context;

            if (mockMode)
            {
                if (progressCallback != null)
                    await progressCallback("Table Analysis", $"Generating mock response for {schemaName}.{tableName} (no AI call)...", null);

                // Simulate AI processing with multiple progress updates
                await Task.Delay(200);
                if (progressCallback != null)
                    await progressCallback("Table Analysis", $"Analyzing table structure for {schemaName}.{tableName}...", null);
                await Task.Delay(200);
                if (progressCallback != null)
                    await progressCallback("Table Analysis", $"Generating business context for {schemaName}.{tableName}...", null);
                await Task.Delay(200);

                // Generate mock context without AI call
                context = MockDataGenerator.GenerateMockTableContext(tableMetadata);

                if (progressCallback != null)
                    await progressCallback("Table Analysis", $"Mock context generated for {schemaName}.{tableName}", null);
                await Task.Delay(100);
            }
            else
            {
                if (progressCallback != null)
                    await progressCallback("Table Analysis", $"Sending AI request for {schemaName}.{tableName}...", null);

                // Get AI analysis using the correct method for business context generation
                var aiResponse = await _aiServiceHelper.GenerateStructuredResponseAsync(prompt);

                if (progressCallback != null)
                    await progressCallback("Table Analysis", $"Parsing AI response for {schemaName}.{tableName}...", null);

                // Parse AI response and create context
                context = ParseTableContextResponse(aiResponse, tableMetadata);
            }

            return context;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating context for table {Schema}.{Table}", schemaName, tableName);
            throw;
        }
    }

    public async Task<AutoGeneratedTableContext> GenerateTableContextWithFieldsAsync(
        string tableName,
        List<string> selectedFieldNames,
        SchemaMetadata schema,
        string? userId = null,
        Func<string, string, string?, Task>? progressCallback = null)
    {
        try
        {
            _logger.LogInformation("üîç Generating context for table {TableName} with {FieldCount} selected fields",
                tableName, selectedFieldNames.Count);

            if (progressCallback != null)
                await progressCallback("AI Processing", $"Analyzing table structure for {tableName}...", null);

            // Find the table in schema
            var tableMetadata = schema.Tables.FirstOrDefault(t => t.Name.Equals(tableName, StringComparison.OrdinalIgnoreCase));
            if (tableMetadata == null)
            {
                _logger.LogWarning("‚ö†Ô∏è Table {TableName} not found in schema", tableName);
                return null;
            }

            if (progressCallback != null)
                await progressCallback("AI Processing", $"Building AI prompt for {tableName}...", null);

            // Build AI prompt focusing on selected fields
            var prompt = BuildTableContextPromptWithFields(tableMetadata, selectedFieldNames, schema);

            if (progressCallback != null)
                await progressCallback("AI Processing", $"Sending request to AI service for {tableName}...", null);

            // Get AI analysis
            var aiResponse = await _aiServiceHelper.GenerateStructuredResponseAsync(prompt);

            if (progressCallback != null)
                await progressCallback("AI Processing", $"Processing AI response for {tableName}...", null);

            // Parse the response
            var tableContext = ParseTableContextResponseWithFields(aiResponse, tableMetadata, selectedFieldNames);

            _logger.LogDebug("‚úÖ Generated context for {TableName} with {FieldCount} fields",
                tableName, selectedFieldNames.Count);

            return tableContext;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Error generating context for table {TableName}", tableName);
            throw;
        }
    }

    private string BuildTableAnalysisPrompt(TableMetadata table)
    {
        var prompt = $@"
Analyze this database table and provide business context for a gaming/casino platform:

Table: {table.Schema}.{table.Name}
Columns: {string.Join(", ", table.Columns.Select(c => $"{c.Name} ({c.DataType})"))}

Based on the table and column names, provide:
1. Business Purpose: What is this table used for in business terms?
2. Business Context: How does this table fit into the overall business process?
3. Primary Use Case: What is the main business scenario this table supports?
4. Key Business Metrics: What important business metrics can be derived from this table?
5. Common Query Patterns: What types of business questions would this table help answer?
6. Business Rules: What business rules or constraints might apply to this data?

Focus on gaming/casino business terminology. Consider concepts like players, deposits, withdrawals, bets, wins, bonuses, games, sessions, etc.

Respond in JSON format:
{{
  ""businessPurpose"": ""..."",
  ""businessContext"": ""..."",
  ""primaryUseCase"": ""..."",
  ""keyBusinessMetrics"": [""...""],
  ""commonQueryPatterns"": [""...""],
  ""businessRules"": ""...""
}}";

        return prompt;
    }

    private string BuildTableContextPromptWithFields(TableMetadata tableMetadata, List<string> selectedFieldNames, SchemaMetadata schema)
    {
        var relevantColumns = tableMetadata.Columns.Where(c => selectedFieldNames.Contains(c.Name)).ToList();

        var prompt = $@"Analyze this database table and generate business context focusing on the selected fields:

TABLE: {tableMetadata.Name}
SCHEMA: {tableMetadata.Schema}

SELECTED FIELDS TO FOCUS ON:
{string.Join("\n", selectedFieldNames.Select(f => $"- {f}"))}

COLUMN DETAILS FOR SELECTED FIELDS:
{string.Join("\n", relevantColumns.Select(c => $"- {c.Name}: {c.DataType} {(c.IsNullable ? "(nullable)" : "(required)")} {(c.IsPrimaryKey ? "(PRIMARY KEY)" : "")} {(c.IsForeignKey ? "(FOREIGN KEY)" : "")}"))}

Generate a JSON response with this exact structure:
{{
  ""businessPurpose"": ""Detailed explanation of what this table represents in business terms"",
  ""businessContext"": ""Additional business context and background"",
  ""primaryUseCase"": ""Primary use case for this table"",
  ""confidenceScore"": 0.85,
  ""keyBusinessMetrics"": [""metric1"", ""metric2""],
  ""commonQueryPatterns"": [""pattern1"", ""pattern2""],
  ""businessRules"": ""Business rules that apply to this table"",
  ""columnContexts"": [
    {{
      ""columnName"": ""column_name"",
      ""businessName"": ""Business-friendly name"",
      ""businessDescription"": ""What this field represents in business terms"",
      ""businessDataType"": ""Text/Number/Date/Boolean"",
      ""confidenceScore"": 0.80
    }}
  ]
}}

Focus specifically on the selected fields: {string.Join(", ", selectedFieldNames)}";

        return prompt;
    }

    private AutoGeneratedTableContext ParseTableContextResponse(string aiResponse, TableMetadata table)
    {
        try
        {
            _logger.LogDebug("ü§ñ AI Response for table {Table}: {Response}", table.Name, aiResponse);

            // Try multiple JSON extraction patterns
            var jsonMatch = Regex.Match(aiResponse, @"\{.*\}", RegexOptions.Singleline);
            if (!jsonMatch.Success)
            {
                // Try alternative patterns
                jsonMatch = Regex.Match(aiResponse, @"```json\s*(\{.*?\})\s*```", RegexOptions.Singleline);
                if (!jsonMatch.Success)
                {
                    jsonMatch = Regex.Match(aiResponse, @"```\s*(\{.*?\})\s*```", RegexOptions.Singleline);
                }
            }

            if (!jsonMatch.Success)
            {
                _logger.LogWarning("‚ö†Ô∏è AI response does not contain valid JSON for table {Table}. Falling back to mock data. Response: {Response}",
                    table.Name, aiResponse);
                return MockDataGenerator.GenerateMockTableContext(table);
            }

            var jsonString = jsonMatch.Groups.Count > 1 ? jsonMatch.Groups[1].Value : jsonMatch.Value;
            _logger.LogDebug("üîç Extracted JSON for table {Table}: {Json}", table.Name, jsonString);

            var jsonResponse = JsonSerializer.Deserialize<Dictionary<string, object>>(jsonString);
            if (jsonResponse == null)
            {
                _logger.LogWarning("‚ö†Ô∏è Failed to parse AI response JSON for table {Table}. Falling back to mock data.", table.Name);
                return MockDataGenerator.GenerateMockTableContext(table);
            }

            return new AutoGeneratedTableContext
            {
                TableName = table.Name,
                SchemaName = table.Schema,
                BusinessPurpose = JsonHelper.GetStringValue(jsonResponse, "businessPurpose"),
                BusinessContext = JsonHelper.GetStringValue(jsonResponse, "businessContext"),
                PrimaryUseCase = JsonHelper.GetStringValue(jsonResponse, "primaryUseCase"),
                KeyBusinessMetrics = JsonHelper.GetStringArrayValue(jsonResponse, "keyBusinessMetrics"),
                CommonQueryPatterns = JsonHelper.GetStringArrayValue(jsonResponse, "commonQueryPatterns"),
                BusinessRules = JsonHelper.GetStringValue(jsonResponse, "businessRules"),
                GeneratedAt = DateTime.UtcNow,
                IsAutoGenerated = true,
                ConfidenceScore = 0.8
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error parsing table context response for {Table}", table.Name);
            return MockDataGenerator.GenerateMockTableContext(table);
        }
    }

    private AutoGeneratedTableContext ParseTableContextResponseWithFields(string aiResponse, TableMetadata tableMetadata, List<string> selectedFieldNames)
    {
        try
        {
            // Log the raw response for debugging
            _logger.LogInformation("ü§ñ Raw AI response for {TableName}: '{Response}'", tableMetadata.Name, aiResponse);

            // Check if response is empty or null
            if (string.IsNullOrWhiteSpace(aiResponse))
            {
                throw new InvalidOperationException($"AI response is empty for table {tableMetadata.Name}");
            }

            // Clean the response
            var cleanResponse = aiResponse.Trim();
            if (cleanResponse.StartsWith("```json"))
            {
                cleanResponse = cleanResponse.Substring(7);
            }
            if (cleanResponse.EndsWith("```"))
            {
                cleanResponse = cleanResponse.Substring(0, cleanResponse.Length - 3);
            }
            cleanResponse = cleanResponse.Trim();

            // Check if it looks like JSON (starts with { or [)
            if (!cleanResponse.StartsWith("{") && !cleanResponse.StartsWith("["))
            {
                throw new InvalidOperationException($"AI response doesn't appear to be JSON for table {tableMetadata.Name}: '{cleanResponse.Substring(0, Math.Min(100, cleanResponse.Length))}'");
            }

            // Parse JSON
            var jsonDoc = JsonDocument.Parse(cleanResponse);
            var root = jsonDoc.RootElement;

            // Create table context
            var tableContext = new AutoGeneratedTableContext
            {
                TableName = tableMetadata.Name,
                SchemaName = tableMetadata.Schema,
                BusinessPurpose = root.GetProperty("businessPurpose").GetString() ?? "Business purpose not available",
                BusinessContext = root.GetProperty("businessContext").GetString() ?? "Business context not available",
                PrimaryUseCase = root.GetProperty("primaryUseCase").GetString() ?? "Primary use case not available",
                ConfidenceScore = root.GetProperty("confidenceScore").GetDouble(),
                KeyBusinessMetrics = root.TryGetProperty("keyBusinessMetrics", out var metricsElement)
                    ? metricsElement.EnumerateArray().Select(m => m.GetString()).Where(m => !string.IsNullOrEmpty(m)).ToList()
                    : new List<string>(),
                CommonQueryPatterns = root.TryGetProperty("commonQueryPatterns", out var patternsElement)
                    ? patternsElement.EnumerateArray().Select(p => p.GetString()).Where(p => !string.IsNullOrEmpty(p)).ToList()
                    : new List<string>(),
                BusinessRules = root.GetProperty("businessRules").GetString() ?? "Standard business rules apply",
                GeneratedAt = DateTime.UtcNow,
                IsAutoGenerated = true,
                Columns = new List<AutoGeneratedColumnContext>()
            };

            // Parse column contexts for selected fields only
            if (root.TryGetProperty("columnContexts", out var columnContextsElement))
            {
                var selectedFieldNamesSet = selectedFieldNames.ToHashSet(StringComparer.OrdinalIgnoreCase);

                foreach (var columnElement in columnContextsElement.EnumerateArray())
                {
                    var columnName = columnElement.GetProperty("columnName").GetString();

                    // Only include contexts for selected fields
                    if (!string.IsNullOrEmpty(columnName) && selectedFieldNamesSet.Contains(columnName))
                    {
                        var columnContext = new AutoGeneratedColumnContext
                        {
                            ColumnName = columnName,
                            BusinessName = columnElement.GetProperty("businessName").GetString() ?? columnName,
                            BusinessDescription = columnElement.GetProperty("businessDescription").GetString() ?? "Business description not available",
                            DataType = "varchar", // Default data type
                            BusinessDataType = columnElement.GetProperty("businessDataType").GetString() ?? "Text",
                            ConfidenceScore = columnElement.GetProperty("confidenceScore").GetDouble(),
                            IsAutoGenerated = true,
                            IsPrimaryKey = false,
                            IsForeignKey = false,
                            SampleValues = new List<string>(),
                            BusinessRules = new List<string>(),
                            CommonUseCases = new List<string>()
                        };

                        tableContext.Columns.Add(columnContext);
                    }
                }
            }

            _logger.LogDebug("‚úÖ Parsed table context for {TableName} with {ColumnCount} column contexts",
                tableMetadata.Name, tableContext.Columns.Count);

            return tableContext;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Error parsing table context response for {TableName}", tableMetadata.Name);
            throw;
        }
    }
}
