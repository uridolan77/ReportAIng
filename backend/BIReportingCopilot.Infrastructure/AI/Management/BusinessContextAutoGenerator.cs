using BIReportingCopilot.Core.Interfaces;
using BIReportingCopilot.Core.Interfaces.AI;
using BIReportingCopilot.Core.Interfaces.Business;
using BIReportingCopilot.Core.Interfaces.Query;
using BIReportingCopilot.Core.Interfaces.Schema;
using BIReportingCopilot.Core.Models;
using Microsoft.Extensions.Logging;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;

namespace BIReportingCopilot.Infrastructure.AI.Management;

public class BusinessContextAutoGenerator : IBusinessContextAutoGenerator
{
    private readonly ISchemaService _schemaService;
    private readonly IAIService _aiService;
    private readonly ILogger<BusinessContextAutoGenerator> _logger;

    // Gaming/Casino domain knowledge for better context generation
    private readonly Dictionary<string, string> _domainPatterns = new()
    {
        ["player"] = "Gaming customer or user account",
        ["deposit"] = "Money added to player account",
        ["withdrawal"] = "Money removed from player account",
        ["bet"] = "Wager placed by player",
        ["win"] = "Amount won by player",
        ["bonus"] = "Promotional credit given to player",
        ["game"] = "Casino game or slot machine",
        ["session"] = "Gaming session or login period",
        ["transaction"] = "Financial transaction",
        ["balance"] = "Account balance or available funds",
        ["currency"] = "Money denomination",
        ["country"] = "Geographic location",
        ["whitelabel"] = "Brand or operator",
        ["casino"] = "Casino gaming platform",
        ["sport"] = "Sports betting platform",
        ["live"] = "Live dealer games",
        ["bingo"] = "Bingo gaming platform"
    };

    public BusinessContextAutoGenerator(
        ISchemaService schemaService,
        IAIService aiService,
        ILogger<BusinessContextAutoGenerator> logger)
    {
        _schemaService = schemaService;
        _aiService = aiService;
        _logger = logger;
    }

    public async Task<List<AutoGeneratedTableContext>> GenerateTableContextsAsync()
    {
        return await GenerateTableContextsAsync(null);
    }

    public async Task<List<AutoGeneratedTableContext>> GenerateTableContextsAsync(Func<string, string, string?, Task>? progressCallback = null)
    {
        _logger.LogInformation("Starting auto-generation of table contexts");
        var results = new List<AutoGeneratedTableContext>();

        try
        {
            if (progressCallback != null)
                await progressCallback("Schema Loading", "Loading database schema...", null);

            var schema = await _schemaService.GetSchemaMetadataAsync();
            var processedTables = 0;

            foreach (var table in schema.Tables)
            {
                try
                {
                    if (progressCallback != null)
                        await progressCallback("Table Processing", $"Processing table {table.Schema}.{table.Name} ({processedTables + 1}/{schema.Tables.Count})", table.Name);

                    var context = await GenerateTableContextAsync(table.Name, table.Schema, progressCallback);
                    results.Add(context);
                    _logger.LogDebug("Generated context for table {Schema}.{Table}", table.Schema, table.Name);
                    processedTables++;
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error generating context for table {Schema}.{Table}", table.Schema, table.Name);
                    processedTables++;
                }
            }

            _logger.LogInformation("Completed auto-generation for {Count} tables", results.Count);
            return results;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in GenerateTableContextsAsync");
            throw;
        }
    }

    public async Task<AutoGeneratedTableContext> GenerateTableContextAsync(string tableName, string schemaName)
    {
        return await GenerateTableContextAsync(tableName, schemaName, null);
    }

    public async Task<AutoGeneratedTableContext> GenerateTableContextAsync(string tableName, string schemaName, Func<string, string, string?, Task>? progressCallback = null)
    {
        return await GenerateTableContextAsync(tableName, schemaName, progressCallback, false);
    }

    public async Task<AutoGeneratedTableContext> GenerateTableContextAsync(string tableName, string schemaName, Func<string, string, string?, Task>? progressCallback = null, bool mockMode = false)
    {
        _logger.LogDebug("Generating context for table {Schema}.{Table} (MockMode: {MockMode})", schemaName, tableName, mockMode);

        try
        {
            if (progressCallback != null)
                await progressCallback("Table Analysis", $"Loading metadata for {schemaName}.{tableName}...", null);

            var tableMetadata = await _schemaService.GetTableMetadataAsync(tableName, schemaName);
            if (tableMetadata == null)
            {
                throw new ArgumentException($"Table {schemaName}.{tableName} not found");
            }

            if (progressCallback != null)
                await progressCallback("Table Analysis", $"Building AI prompt for {schemaName}.{tableName}...", null);

            // Build AI prompt for table analysis
            var prompt = BuildTableAnalysisPrompt(tableMetadata);

            AutoGeneratedTableContext context;

            if (mockMode)
            {
                if (progressCallback != null)
                    await progressCallback("Table Analysis", $"Generating mock response for {schemaName}.{tableName} (no AI call)...", null);

                // Simulate AI processing with multiple progress updates
                await Task.Delay(200);
                if (progressCallback != null)
                    await progressCallback("Table Analysis", $"Analyzing table structure for {schemaName}.{tableName}...", null);
                await Task.Delay(200);
                if (progressCallback != null)
                    await progressCallback("Table Analysis", $"Generating business context for {schemaName}.{tableName}...", null);
                await Task.Delay(200);

                // Generate mock context without AI call
                context = GenerateMockTableContext(tableMetadata);

                if (progressCallback != null)
                    await progressCallback("Table Analysis", $"Mock context generated for {schemaName}.{tableName}", null);
                await Task.Delay(100);
            }
            else
            {
                if (progressCallback != null)
                    await progressCallback("Table Analysis", $"Sending AI request for {schemaName}.{tableName}...", null);

                // Get AI analysis using the correct method for business context generation
                var aiResponse = await GenerateStructuredResponseAsync(prompt);

                if (progressCallback != null)
                    await progressCallback("Table Analysis", $"Parsing AI response for {schemaName}.{tableName}...", null);

                // Parse AI response and create context
                context = ParseTableContextResponse(aiResponse, tableMetadata);
            }

            if (progressCallback != null)
                await progressCallback("Column Analysis", $"Analyzing {tableMetadata.Columns.Count} columns...", null);

            // Generate column contexts with progress reporting
            context.Columns = await GenerateColumnContextsAsync(tableMetadata, progressCallback, mockMode);

            if (progressCallback != null)
                await progressCallback("Relationship Analysis", $"Finding related tables for {schemaName}.{tableName}...", null);

            // Analyze relationships
            context.RelatedTables = await FindRelatedTablesAsync(tableMetadata);

            if (progressCallback != null)
                await progressCallback("Finalization", $"Calculating confidence score for {schemaName}.{tableName}...", null);

            // Calculate confidence score
            context.ConfidenceScore = CalculateTableConfidenceScore(context, tableMetadata);

            return context;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating context for table {Schema}.{Table}", schemaName, tableName);
            throw;
        }
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsAsync()
    {
        _logger.LogInformation("Starting auto-generation of glossary terms for all tables");
        var schema = await _schemaService.GetSchemaMetadataAsync();
        return await GenerateGlossaryTermsAsync(schema.Tables.Select(t => $"{t.Schema}.{t.Name}").ToList());
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsAsync(List<string> specificTables)
    {
        return await GenerateGlossaryTermsAsync(specificTables, null);
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsAsync(List<string> specificTables, Func<string, string, string?, Task>? progressCallback = null)
    {
        return await GenerateGlossaryTermsAsync(specificTables, progressCallback, false);
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsAsync(List<string>? specificTables = null, Func<string, string, string?, Task>? progressCallback = null, bool mockMode = false)
    {
        // Handle null case - if no specific tables provided, generate for all tables
        if (specificTables == null)
        {
            return await GenerateGlossaryTermsAsync();
        }

        _logger.LogInformation("Starting auto-generation of glossary terms for {TableCount} specific tables (MockMode: {MockMode})", specificTables.Count, mockMode);
        var results = new List<AutoGeneratedGlossaryTerm>();

        try
        {
            if (progressCallback != null)
                await progressCallback("Schema Loading", "Loading database schema...", null);

            var schema = await _schemaService.GetSchemaMetadataAsync();
            var allTerms = new HashSet<string>();

            // Filter tables based on specific selection
            var tablesToProcess = schema.Tables.Where(table =>
            {
                var fullTableName = $"{table.Schema}.{table.Name}";
                return specificTables.Contains(fullTableName);
            }).ToList();

            _logger.LogInformation("Processing {ProcessCount} tables out of {TotalCount} available tables",
                tablesToProcess.Count, schema.Tables.Count);

            if (progressCallback != null)
                await progressCallback("Term Extraction", $"Extracting terms from {tablesToProcess.Count} tables...", null);

            // Extract terms from selected table and column names only
            var processedTables = 0;
            foreach (var table in tablesToProcess)
            {
                _logger.LogDebug("Processing table {Schema}.{Table} for glossary terms", table.Schema, table.Name);

                if (progressCallback != null)
                    await progressCallback("Term Extraction", $"Processing table {table.Schema}.{table.Name} ({processedTables + 1}/{tablesToProcess.Count})", table.Name);

                // Add table name terms
                var tableTerms = ExtractBusinessTerms(table.Name);
                foreach (var term in tableTerms)
                {
                    allTerms.Add(term.ToLowerInvariant());
                }

                // Add column name terms
                var processedColumns = 0;
                foreach (var column in table.Columns)
                {
                    if (progressCallback != null)
                        await progressCallback("Column Processing", $"Processing column {column.Name} in {table.Name} ({processedColumns + 1}/{table.Columns.Count})", column.Name);

                    var columnTerms = ExtractBusinessTerms(column.Name);
                    foreach (var term in columnTerms)
                    {
                        allTerms.Add(term.ToLowerInvariant());
                    }
                    processedColumns++;
                }
                processedTables++;
            }

            _logger.LogInformation("Extracted {TermCount} unique terms from selected tables", allTerms.Count);

            if (progressCallback != null)
                await progressCallback("AI Generation", $"Generating definitions for {allTerms.Count} terms...", null);

            // Generate definitions for unique terms
            var processedTerms = 0;
            var validTerms = allTerms.Where(t => t.Length > 2).ToList();

            foreach (var term in validTerms)
            {
                try
                {
                    if (progressCallback != null)
                        await progressCallback("AI Generation", $"Generating definition for '{term}' ({processedTerms + 1}/{validTerms.Count})", term);

                    AutoGeneratedGlossaryTerm glossaryTerm;
                    if (mockMode)
                    {
                        if (progressCallback != null)
                            await progressCallback("AI Generation", $"Analyzing term '{term}' (mock mode)...", term);
                        await Task.Delay(100);
                        if (progressCallback != null)
                            await progressCallback("AI Generation", $"Generating mock definition for '{term}'...", term);
                        await Task.Delay(100);

                        glossaryTerm = GenerateMockGlossaryTerm(term);

                        if (progressCallback != null)
                            await progressCallback("AI Generation", $"Mock definition completed for '{term}'", term);
                        await Task.Delay(50);
                    }
                    else
                    {
                        glossaryTerm = await GenerateGlossaryTermAsync(term, schema);
                    }

                    if (glossaryTerm.ConfidenceScore >= 0.6)
                    {
                        results.Add(glossaryTerm);
                    }
                    processedTerms++;
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Error generating glossary term for: {Term}", term);
                    processedTerms++;
                }
            }

            _logger.LogInformation("Generated {Count} glossary terms from {TableCount} selected tables", results.Count, tablesToProcess.Count);
            return results;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in GenerateGlossaryTermsAsync for specific tables");
            throw;
        }
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateColumnGlossaryAsync(string tableName, string schemaName)
    {
        var results = new List<AutoGeneratedGlossaryTerm>();

        try
        {
            var tableMetadata = await _schemaService.GetTableMetadataAsync(tableName, schemaName);
            if (tableMetadata == null) return results;

            var schema = await _schemaService.GetSchemaMetadataAsync();

            foreach (var column in tableMetadata.Columns)
            {
                var terms = ExtractBusinessTerms(column.Name);
                foreach (var term in terms.Where(t => t.Length > 2))
                {
                    var glossaryTerm = await GenerateGlossaryTermAsync(term, schema, tableName, column.Name);
                    if (glossaryTerm.ConfidenceScore >= 0.6)
                    {
                        results.Add(glossaryTerm);
                    }
                }
            }

            return results;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating column glossary for {Schema}.{Table}", schemaName, tableName);
            return results;
        }
    }

    public async Task<BusinessRelationshipAnalysis> AnalyzeTableRelationshipsAsync()
    {
        _logger.LogInformation("Starting table relationship analysis");

        try
        {
            var schema = await _schemaService.GetSchemaMetadataAsync();
            var analysis = new BusinessRelationshipAnalysis();

            // Analyze foreign key relationships
            analysis.Relationships = await AnalyzeForeignKeyRelationships(schema);

            // Identify business domains
            analysis.BusinessDomains = IdentifyBusinessDomains(schema);

            // Analyze data flows
            analysis.DataFlows = AnalyzeDataFlows(schema, analysis.Relationships);

            // Calculate overall confidence
            analysis.OverallConfidence = CalculateRelationshipConfidence(analysis);

            _logger.LogInformation("Completed relationship analysis with {RelCount} relationships, {DomainCount} domains",
                analysis.Relationships.Count, analysis.BusinessDomains.Count);

            return analysis;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in AnalyzeTableRelationshipsAsync");
            throw;
        }
    }

    private string BuildTableAnalysisPrompt(TableMetadata table)
    {
        var prompt = $@"
Analyze this database table and provide business context for a gaming/casino platform:

Table: {table.Schema}.{table.Name}
Columns: {string.Join(", ", table.Columns.Select(c => $"{c.Name} ({c.DataType})"))}

Based on the table and column names, provide:
1. Business Purpose: What is this table used for in business terms?
2. Business Context: How does this table fit into the overall business process?
3. Primary Use Case: What is the main business scenario this table supports?
4. Key Business Metrics: What important business metrics can be derived from this table?
5. Common Query Patterns: What types of business questions would this table help answer?
6. Business Rules: What business rules or constraints might apply to this data?

Focus on gaming/casino business terminology. Consider concepts like players, deposits, withdrawals, bets, wins, bonuses, games, sessions, etc.

Respond in JSON format:
{{
  ""businessPurpose"": ""..."",
  ""businessContext"": ""..."",
  ""primaryUseCase"": ""..."",
  ""keyBusinessMetrics"": [""...""],
  ""commonQueryPatterns"": [""...""],
  ""businessRules"": ""...""
}}";

        return prompt;
    }

    private AutoGeneratedTableContext ParseTableContextResponse(string aiResponse, TableMetadata table)
    {
        try
        {
            _logger.LogDebug("🤖 AI Response for table {Table}: {Response}", table.Name, aiResponse);

            // Try multiple JSON extraction patterns
            var jsonMatch = Regex.Match(aiResponse, @"\{.*\}", RegexOptions.Singleline);
            if (!jsonMatch.Success)
            {
                // Try alternative patterns
                jsonMatch = Regex.Match(aiResponse, @"```json\s*(\{.*?\})\s*```", RegexOptions.Singleline);
                if (!jsonMatch.Success)
                {
                    jsonMatch = Regex.Match(aiResponse, @"```\s*(\{.*?\})\s*```", RegexOptions.Singleline);
                }
            }

            if (!jsonMatch.Success)
            {
                _logger.LogWarning("⚠️ AI response does not contain valid JSON for table {Table}. Falling back to mock data. Response: {Response}",
                    table.Name, aiResponse);
                return GenerateMockTableContext(table);
            }

            var jsonString = jsonMatch.Groups.Count > 1 ? jsonMatch.Groups[1].Value : jsonMatch.Value;
            _logger.LogDebug("🔍 Extracted JSON for table {Table}: {Json}", table.Name, jsonString);

            var jsonResponse = JsonSerializer.Deserialize<Dictionary<string, object>>(jsonString);
            if (jsonResponse == null)
            {
                _logger.LogWarning("⚠️ Failed to parse AI response JSON for table {Table}. Falling back to mock data.", table.Name);
                return GenerateMockTableContext(table);
            }

            return new AutoGeneratedTableContext
            {
                TableName = table.Name,
                SchemaName = table.Schema,
                BusinessPurpose = GetStringValue(jsonResponse, "businessPurpose"),
                BusinessContext = GetStringValue(jsonResponse, "businessContext"),
                PrimaryUseCase = GetStringValue(jsonResponse, "primaryUseCase"),
                KeyBusinessMetrics = GetStringArrayValue(jsonResponse, "keyBusinessMetrics"),
                CommonQueryPatterns = GetStringArrayValue(jsonResponse, "commonQueryPatterns"),
                BusinessRules = GetStringValue(jsonResponse, "businessRules"),
                GeneratedAt = DateTime.UtcNow,
                IsAutoGenerated = true,
                ConfidenceScore = 0.8
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "❌ Error parsing AI response for table {Table}. Falling back to mock data. Response: {Response}",
                table.Name, aiResponse);
            return GenerateMockTableContext(table);
        }
    }

    private string BuildGlossaryTermPrompt(string term, SchemaMetadata schema, string? sourceTable = null, string? sourceColumn = null)
    {
        var prompt = new StringBuilder();

        prompt.AppendLine("You are a business analyst specializing in database schema analysis and business terminology.");
        prompt.AppendLine("Analyze the following business term and provide comprehensive business context.");
        prompt.AppendLine();
        prompt.AppendLine($"TERM TO ANALYZE: {term}");

        if (!string.IsNullOrEmpty(sourceTable))
        {
            prompt.AppendLine($"SOURCE TABLE: {sourceTable}");
        }

        if (!string.IsNullOrEmpty(sourceColumn))
        {
            prompt.AppendLine($"SOURCE COLUMN: {sourceColumn}");
        }

        prompt.AppendLine();
        prompt.AppendLine("CONTEXT - Database Schema Information:");

        // Add relevant table information
        var relevantTables = schema.Tables.Where(t =>
            t.Name.ToLowerInvariant().Contains(term.ToLowerInvariant()) ||
            t.Columns.Any(c => c.Name.ToLowerInvariant().Contains(term.ToLowerInvariant())) ||
            (!string.IsNullOrEmpty(sourceTable) && t.Name.Equals(sourceTable, StringComparison.OrdinalIgnoreCase))
        ).Take(3);

        foreach (var table in relevantTables)
        {
            prompt.AppendLine($"Table: {table.Schema}.{table.Name}");
            var relevantColumns = table.Columns.Where(c =>
                c.Name.ToLowerInvariant().Contains(term.ToLowerInvariant()) ||
                (!string.IsNullOrEmpty(sourceColumn) && c.Name.Equals(sourceColumn, StringComparison.OrdinalIgnoreCase))
            ).Take(5);

            foreach (var col in relevantColumns)
            {
                prompt.AppendLine($"  - {col.Name} ({col.DataType}){(col.IsPrimaryKey ? " [PK]" : "")}{(col.IsForeignKey ? " [FK]" : "")}");
            }
        }

        prompt.AppendLine();
        prompt.AppendLine("INSTRUCTIONS:");
        prompt.AppendLine("Provide a JSON response with the following structure:");
        prompt.AppendLine("{");
        prompt.AppendLine("  \"definition\": \"Clear, concise business definition of the term\",");
        prompt.AppendLine("  \"businessContext\": \"How this term is used in business operations\",");
        prompt.AppendLine("  \"category\": \"Business category (e.g., Financial, Geographic, Identifier, etc.)\",");
        prompt.AppendLine("  \"synonyms\": [\"list\", \"of\", \"alternative\", \"terms\"],");
        prompt.AppendLine("  \"relatedTerms\": [\"list\", \"of\", \"related\", \"business\", \"terms\"],");
        prompt.AppendLine("  \"confidenceScore\": 0.85");
        prompt.AppendLine("}");
        prompt.AppendLine();
        prompt.AppendLine("Focus on business meaning rather than technical implementation.");
        prompt.AppendLine("Consider the gaming/casino industry context if applicable.");

        return prompt.ToString();
    }

    private AutoGeneratedGlossaryTerm ParseGlossaryTermResponse(string aiResponse, string term, string? sourceTable = null, string? sourceColumn = null)
    {
        try
        {
            // Clean up the response to extract JSON
            var jsonMatch = Regex.Match(aiResponse, @"\{.*\}", RegexOptions.Singleline);
            if (!jsonMatch.Success)
            {
                throw new InvalidOperationException($"AI response does not contain valid JSON for term {term}");
            }

            var jsonResponse = JsonSerializer.Deserialize<Dictionary<string, object>>(jsonMatch.Value);
            if (jsonResponse == null)
            {
                throw new InvalidOperationException($"Failed to parse AI response JSON for term {term}");
            }

            return new AutoGeneratedGlossaryTerm
            {
                Term = term,
                Definition = GetStringValue(jsonResponse, "definition"),
                BusinessContext = GetStringValue(jsonResponse, "businessContext"),
                Category = GetStringValue(jsonResponse, "category"),
                Synonyms = GetStringArrayValue(jsonResponse, "synonyms"),
                RelatedTerms = GetStringArrayValue(jsonResponse, "relatedTerms"),
                ConfidenceScore = GetDoubleValue(jsonResponse, "confidenceScore", 0.7),
                GeneratedAt = DateTime.UtcNow,
                IsAutoGenerated = true,
                SourceTables = !string.IsNullOrEmpty(sourceTable) ? new List<string> { sourceTable } : new List<string>(),
                SourceColumns = !string.IsNullOrEmpty(sourceColumn) ? new List<string> { sourceColumn } : new List<string>()
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error parsing AI response for glossary term {Term}", term);
            throw;
        }
    }

    private async Task<List<AutoGeneratedColumnContext>> GenerateColumnContextsAsync(TableMetadata table)
    {
        return await GenerateColumnContextsAsync(table, null);
    }

    private async Task<List<AutoGeneratedColumnContext>> GenerateColumnContextsAsync(TableMetadata table, Func<string, string, string?, Task>? progressCallback = null, bool mockMode = false)
    {
        var results = new List<AutoGeneratedColumnContext>();
        var processedColumns = 0;

        foreach (var column in table.Columns)
        {
            if (progressCallback != null)
                await progressCallback("Column Analysis", $"Processing column {column.Name} ({processedColumns + 1}/{table.Columns.Count})", column.Name);

            // Add detailed progress in mock mode
            if (mockMode && progressCallback != null)
            {
                await progressCallback("Column Analysis", $"Analyzing column {column.Name} (mock mode)...", column.Name);
                await Task.Delay(50);
                await progressCallback("Column Analysis", $"Generating business context for {column.Name}...", column.Name);
                await Task.Delay(50);
            }

            var context = new AutoGeneratedColumnContext
            {
                ColumnName = column.Name,
                BusinessName = GenerateBusinessName(column.Name),
                BusinessDescription = GenerateColumnDescription(column, table.Name),
                DataType = column.DataType,
                BusinessDataType = MapToBusinessDataType(column.DataType),
                IsPrimaryKey = column.IsPrimaryKey,
                IsForeignKey = column.IsForeignKey,
                ConfidenceScore = CalculateColumnConfidenceScore(column),
                IsAutoGenerated = true
            };

            // Add business rules based on column patterns
            context.BusinessRules = GenerateColumnBusinessRules(column);
            context.CommonUseCases = GenerateColumnUseCases(column, table.Name);

            results.Add(context);
            processedColumns++;

            // Final progress update for this column
            if (progressCallback != null)
                await progressCallback("Column Analysis", $"Completed column {column.Name} ({processedColumns}/{table.Columns.Count})", column.Name);

            if (mockMode)
            {
                await Task.Delay(25); // Small delay to see progress
            }
        }

        return results;
    }

    private async Task<List<string>> FindRelatedTablesAsync(TableMetadata table)
    {
        var relatedTables = new List<string>();

        try
        {
            var schema = await _schemaService.GetSchemaMetadataAsync();

            // Find tables with similar naming patterns
            var tableNameParts = ExtractBusinessTerms(table.Name);

            foreach (var otherTable in schema.Tables.Where(t => t.Name != table.Name))
            {
                var otherNameParts = ExtractBusinessTerms(otherTable.Name);
                var commonTerms = tableNameParts.Intersect(otherNameParts, StringComparer.OrdinalIgnoreCase).Count();

                if (commonTerms > 0)
                {
                    relatedTables.Add($"{otherTable.Schema}.{otherTable.Name}");
                }
            }

            // Find tables with foreign key relationships
            foreach (var column in table.Columns.Where(c => c.IsForeignKey))
            {
                // Simple heuristic: look for tables with similar column names
                var potentialReferences = schema.Tables
                    .Where(t => t.Columns.Any(c => c.Name.Equals(column.Name, StringComparison.OrdinalIgnoreCase) && c.IsPrimaryKey))
                    .Select(t => $"{t.Schema}.{t.Name}")
                    .ToList();

                relatedTables.AddRange(potentialReferences);
            }

            return relatedTables.Distinct().ToList();
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error finding related tables for {Table}", table.Name);
            return relatedTables;
        }
    }

    private async Task<AutoGeneratedGlossaryTerm> GenerateGlossaryTermAsync(string term, SchemaMetadata schema, string? sourceTable = null, string? sourceColumn = null)
    {
        try
        {
            _logger.LogDebug("Generating AI-powered glossary term for: {Term}", term);

            // Build AI prompt for glossary term analysis
            var prompt = BuildGlossaryTermPrompt(term, schema, sourceTable, sourceColumn);

            // Get AI analysis using the correct method for business context generation
            var aiResponse = await GenerateStructuredResponseAsync(prompt);

            // Parse AI response
            var glossaryTerm = ParseGlossaryTermResponse(aiResponse, term, sourceTable, sourceColumn);

            _logger.LogDebug("Generated AI glossary term for {Term} with confidence {Confidence}",
                term, glossaryTerm.ConfidenceScore);

            return glossaryTerm;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating AI glossary term for: {Term}", term);

            // Fallback to basic term generation
            return new AutoGeneratedGlossaryTerm
            {
                Term = term,
                Definition = $"Business term: {term}",
                BusinessContext = $"Context for {term} in business operations",
                Synonyms = new List<string>(),
                RelatedTerms = new List<string>(),
                Category = "Business",
                ConfidenceScore = 0.3,
                GeneratedAt = DateTime.UtcNow,
                IsAutoGenerated = true,
                SourceTables = !string.IsNullOrEmpty(sourceTable) ? new List<string> { sourceTable } : new List<string>(),
                SourceColumns = !string.IsNullOrEmpty(sourceColumn) ? new List<string> { sourceColumn } : new List<string>()
            };
        }
    }

    private Task<List<TableRelationship>> AnalyzeForeignKeyRelationships(SchemaMetadata schema)
    {
        var relationships = new List<TableRelationship>();

        foreach (var table in schema.Tables)
        {
            foreach (var column in table.Columns.Where(c => c.IsForeignKey))
            {
                // Find potential referenced tables
                var referencedTables = schema.Tables
                    .Where(t => t.Columns.Any(c => c.Name.Equals(column.Name, StringComparison.OrdinalIgnoreCase) && c.IsPrimaryKey))
                    .ToList();

                foreach (var referencedTable in referencedTables)
                {
                    var relationship = new TableRelationship
                    {
                        FromTable = table.Name,
                        FromSchema = table.Schema,
                        ToTable = referencedTable.Name,
                        ToSchema = referencedTable.Schema,
                        RelationshipType = "ManyToOne",
                        BusinessRelationship = GenerateBusinessRelationship(table.Name, referencedTable.Name),
                        ColumnMappings = new List<ColumnMapping>
                        {
                            new ColumnMapping
                            {
                                FromColumn = column.Name,
                                ToColumn = column.Name,
                                BusinessMeaning = GenerateColumnRelationshipMeaning(column.Name, table.Name, referencedTable.Name)
                            }
                        },
                        ConfidenceScore = 0.8
                    };

                    relationships.Add(relationship);
                }
            }
        }

        return Task.FromResult(relationships);
    }

    private List<BusinessDomain> IdentifyBusinessDomains(SchemaMetadata schema)
    {
        var domains = new List<BusinessDomain>();

        // Gaming domain patterns
        var gamingPatterns = new Dictionary<string, List<string>>
        {
            ["Player Management"] = new() { "player", "user", "account", "profile" },
            ["Financial Transactions"] = new() { "deposit", "withdrawal", "transaction", "payment", "balance" },
            ["Gaming Activity"] = new() { "bet", "win", "game", "session", "play" },
            ["Bonus System"] = new() { "bonus", "promotion", "reward", "campaign" },
            ["Platform Management"] = new() { "whitelabel", "brand", "operator", "config" },
            ["Geographic Data"] = new() { "country", "region", "currency", "locale" }
        };

        foreach (var pattern in gamingPatterns)
        {
            var matchingTables = schema.Tables
                .Where(t => pattern.Value.Any(keyword =>
                    t.Name.ToLowerInvariant().Contains(keyword) ||
                    t.Columns.Any(c => c.Name.ToLowerInvariant().Contains(keyword))))
                .Select(t => $"{t.Schema}.{t.Name}")
                .ToList();

            if (matchingTables.Any())
            {
                domains.Add(new BusinessDomain
                {
                    DomainName = pattern.Key,
                    Description = $"Tables related to {pattern.Key.ToLowerInvariant()} in the gaming platform",
                    Tables = matchingTables,
                    KeyConcepts = pattern.Value,
                    ConfidenceScore = 0.7
                });
            }
        }

        return domains;
    }

    private List<DataFlow> AnalyzeDataFlows(SchemaMetadata schema, List<TableRelationship> relationships)
    {
        var dataFlows = new List<DataFlow>();

        // Common gaming data flows
        var commonFlows = new Dictionary<string, (string process, List<string> sequence)>
        {
            ["Player Registration"] = ("New player onboarding", new() { "players", "accounts", "profiles" }),
            ["Deposit Process"] = ("Player funding account", new() { "players", "transactions", "balances" }),
            ["Gaming Session"] = ("Player gaming activity", new() { "sessions", "bets", "games", "wins" }),
            ["Withdrawal Process"] = ("Player cashing out", new() { "balances", "withdrawals", "transactions" }),
            ["Bonus Allocation"] = ("Bonus distribution", new() { "bonuses", "players", "balances" })
        };

        foreach (var flow in commonFlows)
        {
            var matchingTables = new List<string>();

            foreach (var tablePattern in flow.Value.sequence)
            {
                var matches = schema.Tables
                    .Where(t => t.Name.ToLowerInvariant().Contains(tablePattern))
                    .Select(t => $"{t.Schema}.{t.Name}")
                    .ToList();

                matchingTables.AddRange(matches);
            }

            if (matchingTables.Count >= 2)
            {
                dataFlows.Add(new DataFlow
                {
                    FlowName = flow.Key,
                    BusinessProcess = flow.Value.process,
                    TableSequence = matchingTables.Distinct().ToList(),
                    Description = $"Data flow for {flow.Value.process} involving {matchingTables.Count} tables",
                    ConfidenceScore = 0.6
                });
            }
        }

        return dataFlows;
    }

    // Helper methods for business context generation
    private string GenerateBusinessName(string technicalName)
    {
        // Convert technical names to business-friendly names
        var name = technicalName.Replace("tbl_", "").Replace("_", " ");

        // Apply domain-specific transformations
        foreach (var pattern in _domainPatterns)
        {
            if (name.ToLowerInvariant().Contains(pattern.Key))
            {
                name = name.Replace(pattern.Key, pattern.Value, StringComparison.OrdinalIgnoreCase);
            }
        }

        return System.Globalization.CultureInfo.CurrentCulture.TextInfo.ToTitleCase(name.ToLowerInvariant());
    }

    private string GenerateColumnDescription(ColumnMetadata column, string tableName)
    {
        var businessName = GenerateBusinessName(column.Name);
        var tableBusinessName = GenerateBusinessName(tableName);

        if (column.IsPrimaryKey)
        {
            return $"Unique identifier for {tableBusinessName}";
        }

        if (column.IsForeignKey)
        {
            return $"Reference to related {businessName} record";
        }

        // Check for common patterns
        var lowerName = column.Name.ToLowerInvariant();
        if (lowerName.Contains("date") || lowerName.Contains("time"))
        {
            return $"Date/time when {businessName} occurred";
        }

        if (lowerName.Contains("amount") || lowerName.Contains("value"))
        {
            return $"Monetary amount for {businessName}";
        }

        if (lowerName.Contains("count") || lowerName.Contains("number"))
        {
            return $"Count or number of {businessName}";
        }

        return $"{businessName} information for {tableBusinessName}";
    }

    private string MapToBusinessDataType(string technicalDataType)
    {
        return technicalDataType.ToLowerInvariant() switch
        {
            var t when t.Contains("varchar") || t.Contains("char") || t.Contains("text") => "Text",
            var t when t.Contains("int") || t.Contains("bigint") => "Number",
            var t when t.Contains("decimal") || t.Contains("money") || t.Contains("float") => "Currency/Decimal",
            var t when t.Contains("date") || t.Contains("time") => "Date/Time",
            var t when t.Contains("bit") || t.Contains("bool") => "Yes/No",
            var t when t.Contains("uniqueidentifier") => "Unique ID",
            _ => "Data"
        };
    }

    private List<string> GenerateColumnBusinessRules(ColumnMetadata column)
    {
        var rules = new List<string>();

        if (!column.IsNullable)
        {
            rules.Add("Required field - cannot be empty");
        }

        if (column.IsPrimaryKey)
        {
            rules.Add("Must be unique across all records");
        }

        var lowerName = column.Name.ToLowerInvariant();
        if (lowerName.Contains("email"))
        {
            rules.Add("Must be valid email format");
        }

        if (lowerName.Contains("amount") || lowerName.Contains("balance"))
        {
            rules.Add("Must be non-negative value");
        }

        if (lowerName.Contains("date"))
        {
            rules.Add("Must be valid date");
        }

        return rules;
    }

    private List<string> GenerateColumnUseCases(ColumnMetadata column, string tableName)
    {
        var useCases = new List<string>();
        var businessName = GenerateBusinessName(column.Name);
        var tableBusinessName = GenerateBusinessName(tableName);

        useCases.Add($"Filter {tableBusinessName} by {businessName}");
        useCases.Add($"Sort {tableBusinessName} by {businessName}");

        var lowerName = column.Name.ToLowerInvariant();
        if (lowerName.Contains("amount") || lowerName.Contains("value"))
        {
            useCases.Add($"Calculate total {businessName}");
            useCases.Add($"Calculate average {businessName}");
        }

        if (lowerName.Contains("date"))
        {
            useCases.Add($"Group by {businessName} period");
            useCases.Add($"Filter by {businessName} range");
        }

        if (lowerName.Contains("count"))
        {
            useCases.Add($"Sum total {businessName}");
        }

        return useCases;
    }

    private List<string> ExtractBusinessTerms(string name)
    {
        // Split on common separators and extract meaningful terms
        var terms = new List<string>();
        var cleanName = name.Replace("tbl_", "").Replace("_", " ");

        // Split on various separators
        var parts = Regex.Split(cleanName, @"[_\s\-\.]+", RegexOptions.IgnoreCase)
            .Where(p => !string.IsNullOrWhiteSpace(p) && p.Length > 1)
            .ToList();

        terms.AddRange(parts);

        // Also try camelCase splitting
        var camelCaseParts = Regex.Split(name, @"(?<!^)(?=[A-Z])", RegexOptions.IgnoreCase)
            .Where(p => !string.IsNullOrWhiteSpace(p) && p.Length > 1)
            .ToList();

        terms.AddRange(camelCaseParts);

        return terms.Distinct(StringComparer.OrdinalIgnoreCase).ToList();
    }

    private string GenerateBusinessRelationship(string fromTable, string toTable)
    {
        var fromBusiness = GenerateBusinessName(fromTable);
        var toBusiness = GenerateBusinessName(toTable);
        return $"{fromBusiness} is related to {toBusiness}";
    }

    private string GenerateColumnRelationshipMeaning(string columnName, string fromTable, string toTable)
    {
        var columnBusiness = GenerateBusinessName(columnName);
        var fromBusiness = GenerateBusinessName(fromTable);
        var toBusiness = GenerateBusinessName(toTable);
        return $"{columnBusiness} links {fromBusiness} to {toBusiness}";
    }

    // Confidence calculation methods
    private double CalculateTableConfidenceScore(AutoGeneratedTableContext context, TableMetadata table)
    {
        double score = 0.5; // Base score

        // Increase confidence based on recognizable patterns
        var lowerTableName = table.Name.ToLowerInvariant();
        foreach (var pattern in _domainPatterns.Keys)
        {
            if (lowerTableName.Contains(pattern))
            {
                score += 0.1;
            }
        }

        // Increase confidence based on column patterns
        var recognizedColumns = table.Columns.Count(c =>
            _domainPatterns.Keys.Any(p => c.Name.ToLowerInvariant().Contains(p)));

        score += (double)recognizedColumns / table.Columns.Count * 0.3;

        // Cap at 0.9 for auto-generated content
        return Math.Min(score, 0.9);
    }

    private double CalculateColumnConfidenceScore(ColumnMetadata column)
    {
        double score = 0.5; // Base score

        var lowerName = column.Name.ToLowerInvariant();

        // Increase confidence for recognized patterns
        foreach (var pattern in _domainPatterns.Keys)
        {
            if (lowerName.Contains(pattern))
            {
                score += 0.2;
                break;
            }
        }

        // Increase confidence for standard patterns
        if (lowerName.Contains("id") || column.IsPrimaryKey || column.IsForeignKey)
            score += 0.1;

        if (lowerName.Contains("date") || lowerName.Contains("time"))
            score += 0.1;

        if (lowerName.Contains("amount") || lowerName.Contains("value"))
            score += 0.1;

        return Math.Min(score, 0.9);
    }

    private double CalculateRelationshipConfidence(BusinessRelationshipAnalysis analysis)
    {
        if (!analysis.Relationships.Any())
            return 0.3;

        var avgRelationshipConfidence = analysis.Relationships.Average(r => r.ConfidenceScore);
        var avgDomainConfidence = analysis.BusinessDomains.Any()
            ? analysis.BusinessDomains.Average(d => d.ConfidenceScore)
            : 0.5;

        return (avgRelationshipConfidence + avgDomainConfidence) / 2;
    }

    // Utility methods for parsing AI responses
    private string GetStringValue(Dictionary<string, object> dict, string key)
    {
        if (dict.TryGetValue(key, out var value))
        {
            return value?.ToString() ?? string.Empty;
        }
        return string.Empty;
    }

    private List<string> GetStringArrayValue(Dictionary<string, object> dict, string key)
    {
        if (dict.TryGetValue(key, out var value))
        {
            if (value is JsonElement element && element.ValueKind == JsonValueKind.Array)
            {
                return element.EnumerateArray()
                    .Select(e => e.GetString() ?? string.Empty)
                    .Where(s => !string.IsNullOrEmpty(s))
                    .ToList();
            }
        }
        return new List<string>();
    }

    private double GetDoubleValue(Dictionary<string, object> dict, string key, double defaultValue = 0.0)
    {
        if (dict.TryGetValue(key, out var value))
        {
            if (value is JsonElement element && element.ValueKind == JsonValueKind.Number)
            {
                return element.GetDouble();
            }
            if (double.TryParse(value?.ToString(), out var doubleValue))
            {
                return doubleValue;
            }
        }
        return defaultValue;
    }

    private AutoGeneratedTableContext GenerateMockTableContext(TableMetadata table)
    {
        var tableName = table.Name.ToLowerInvariant();
        var schemaName = table.Schema;

        // Generate realistic business context based on table name patterns
        string businessPurpose, businessContext, primaryUseCase, businessRules;
        List<string> keyBusinessMetrics, commonQueryPatterns;

        if (tableName.Contains("daily_actions") || tableName.Contains("dailyactions"))
        {
            businessPurpose = "Tracks daily player activities and gaming statistics for business intelligence and reporting";
            businessContext = "Central table for daily aggregated player data including deposits, bets, wins, and other key gaming metrics";
            primaryUseCase = "Generate daily, weekly, and monthly reports on player activity and platform performance";
            keyBusinessMetrics = new List<string> { "Daily Active Players", "Total Deposits", "Total Bets", "Total Wins", "Player Retention" };
            commonQueryPatterns = new List<string> { "Daily activity summaries", "Player performance analysis", "Revenue tracking queries" };
            businessRules = "Data is aggregated daily and should maintain referential integrity with player and transaction tables";
        }
        else if (tableName.Contains("player") || tableName.Contains("user"))
        {
            businessPurpose = "Stores comprehensive player profile information and account details";
            businessContext = "Master table containing player demographics, registration data, and account status information";
            primaryUseCase = "Player management, KYC compliance, customer support, and personalized gaming experiences";
            keyBusinessMetrics = new List<string> { "Total Players", "Active Players", "New Registrations", "Player Lifetime Value" };
            commonQueryPatterns = new List<string> { "Player lookup queries", "Demographics analysis", "Account status updates" };
            businessRules = "Email addresses must be unique, registration dates cannot be future dates, player status must be valid";
        }
        else if (tableName.Contains("countries") || tableName.Contains("country"))
        {
            businessPurpose = "Reference table for country codes, names, and regional gaming regulations";
            businessContext = "Supports geo-location services, compliance requirements, and regional business rules";
            primaryUseCase = "Player registration validation, regulatory compliance, and regional market analysis";
            keyBusinessMetrics = new List<string> { "Players by Country", "Revenue by Region", "Market Penetration" };
            commonQueryPatterns = new List<string> { "Country-based filtering", "Regional compliance checks", "Geographic reporting" };
            businessRules = "Country codes must follow ISO standards, country names must be unique and properly formatted";
        }
        else if (tableName.Contains("currencies") || tableName.Contains("currency"))
        {
            businessPurpose = "Manages supported currencies, exchange rates, and multi-currency transactions";
            businessContext = "Enables global operations with proper currency conversion and financial reporting";
            primaryUseCase = "Multi-currency deposits, withdrawals, and financial reporting across different markets";
            keyBusinessMetrics = new List<string> { "Transactions by Currency", "Exchange Rate Variations", "Currency Distribution" };
            commonQueryPatterns = new List<string> { "Currency conversion queries", "Multi-currency reporting", "Exchange rate updates" };
            businessRules = "Currency codes must be valid ISO codes, exchange rates must be positive, base currency must be defined";
        }
        else if (tableName.Contains("whitelabel") || tableName.Contains("white_label"))
        {
            businessPurpose = "Manages white-label partner configurations and brand-specific settings";
            businessContext = "Supports multi-brand operations with customized gaming experiences for different partners";
            primaryUseCase = "Brand management, partner-specific configurations, and revenue sharing calculations";
            keyBusinessMetrics = new List<string> { "Revenue by Brand", "Players by White Label", "Brand Performance" };
            commonQueryPatterns = new List<string> { "Brand-specific queries", "Partner reporting", "Configuration management" };
            businessRules = "White label IDs must be unique, brand configurations must be valid, partner agreements must be active";
        }
        else if (tableName.Contains("bonus") || tableName.Contains("promotion"))
        {
            businessPurpose = "Manages player bonus campaigns, promotions, and reward distributions";
            businessContext = "Tracks all bonus-related activities including bonus types, amounts, conditions, and player eligibility";
            primaryUseCase = "Monitor bonus effectiveness, player engagement with promotions, and bonus liability management";
            keyBusinessMetrics = new List<string> { "Bonus Conversion Rate", "Total Bonus Amount", "Active Bonuses", "Bonus ROI" };
            commonQueryPatterns = new List<string> { "Bonus eligibility checks", "Promotion performance analysis", "Player bonus history" };
            businessRules = "Bonus amounts must be positive, expiration dates must be future dates, and bonus conditions must be met";
        }
        else
        {
            // Default fallback for unknown table types
            var cleanTableName = tableName.Replace("tbl_", "").Replace("_", " ").Trim();
            businessPurpose = $"Manages {cleanTableName} data for gaming platform operations";
            businessContext = $"Supporting table for {cleanTableName} functionality within the gaming ecosystem";
            primaryUseCase = $"Store and retrieve {cleanTableName} information for business operations";
            keyBusinessMetrics = new List<string> { $"{cleanTableName} Count", $"{cleanTableName} Activity", "Data Quality Score" };
            commonQueryPatterns = new List<string> { $"{cleanTableName} lookup queries", $"{cleanTableName} reporting", $"{cleanTableName} management" };
            businessRules = "Standard data integrity constraints and business validation rules apply to this table";
        }

        return new AutoGeneratedTableContext
        {
            TableName = table.Name,
            SchemaName = table.Schema,
            BusinessPurpose = businessPurpose,
            BusinessContext = businessContext,
            PrimaryUseCase = primaryUseCase,
            KeyBusinessMetrics = keyBusinessMetrics,
            CommonQueryPatterns = commonQueryPatterns,
            BusinessRules = businessRules,
            GeneratedAt = DateTime.UtcNow,
            IsAutoGenerated = true,
            ConfidenceScore = 0.85 // Mock confidence score
        };
    }

    private AutoGeneratedGlossaryTerm GenerateMockGlossaryTerm(string term)
    {
        var lowerTerm = term.ToLowerInvariant();

        // Generate realistic business definitions based on common gaming terms
        string definition, businessContext, category;
        List<string> synonyms, relatedTerms;

        if (lowerTerm.Contains("player") || lowerTerm.Contains("user"))
        {
            definition = "An individual who participates in gaming activities on the platform";
            businessContext = "Central entity in all gaming operations, representing customers who engage with games and services";
            category = "Customer Management";
            synonyms = new List<string> { "customer", "user", "gamer", "participant" };
            relatedTerms = new List<string> { "account", "registration", "profile", "activity" };
        }
        else if (lowerTerm.Contains("deposit") || lowerTerm.Contains("payment"))
        {
            definition = "Financial transaction where funds are added to a player's account";
            businessContext = "Critical revenue operation enabling players to fund their gaming activities";
            category = "Financial Operations";
            synonyms = new List<string> { "payment", "funding", "top-up", "credit" };
            relatedTerms = new List<string> { "withdrawal", "balance", "transaction", "currency" };
        }
        else if (lowerTerm.Contains("bet") || lowerTerm.Contains("wager"))
        {
            definition = "Amount of money risked by a player on a gaming outcome";
            businessContext = "Core gaming activity representing player engagement and potential revenue";
            category = "Gaming Operations";
            synonyms = new List<string> { "wager", "stake", "risk", "play" };
            relatedTerms = new List<string> { "win", "loss", "odds", "payout" };
        }
        else if (lowerTerm.Contains("bonus") || lowerTerm.Contains("promotion"))
        {
            definition = "Promotional reward or incentive offered to players";
            businessContext = "Marketing tool used to attract and retain players through additional value";
            category = "Marketing & Promotions";
            synonyms = new List<string> { "promotion", "reward", "incentive", "offer" };
            relatedTerms = new List<string> { "campaign", "eligibility", "terms", "conditions" };
        }
        else if (lowerTerm.Contains("currency") || lowerTerm.Contains("money"))
        {
            definition = "Medium of exchange used for transactions on the platform";
            businessContext = "Enables multi-currency operations and global market access";
            category = "Financial Operations";
            synonyms = new List<string> { "money", "funds", "denomination", "tender" };
            relatedTerms = new List<string> { "exchange", "rate", "conversion", "balance" };
        }
        else if (lowerTerm.Contains("country") || lowerTerm.Contains("region"))
        {
            definition = "Geographic location or jurisdiction for regulatory and business purposes";
            businessContext = "Supports compliance, localization, and regional business rules";
            category = "Geographic & Regulatory";
            synonyms = new List<string> { "region", "territory", "jurisdiction", "market" };
            relatedTerms = new List<string> { "regulation", "compliance", "license", "restriction" };
        }
        else if (lowerTerm.Contains("action") || lowerTerm.Contains("activity"))
        {
            definition = "Specific behavior or transaction performed by a player";
            businessContext = "Trackable events that provide insights into player behavior and platform usage";
            category = "Analytics & Tracking";
            synonyms = new List<string> { "activity", "event", "behavior", "transaction" };
            relatedTerms = new List<string> { "tracking", "analytics", "reporting", "metrics" };
        }
        else
        {
            // Default fallback
            var cleanTerm = term.Replace("_", " ").Trim();
            definition = $"Business term related to {cleanTerm} in gaming platform operations";
            businessContext = $"Supports {cleanTerm} functionality within the gaming ecosystem";
            category = "General Business";
            synonyms = new List<string> { cleanTerm };
            relatedTerms = new List<string> { "platform", "operations", "management" };
        }

        return new AutoGeneratedGlossaryTerm
        {
            Term = term,
            Definition = definition,
            BusinessContext = businessContext,
            Category = category,
            Synonyms = synonyms,
            RelatedTerms = relatedTerms,
            ConfidenceScore = 0.80,
            GeneratedAt = DateTime.UtcNow,
            IsAutoGenerated = true,
            SourceTables = new List<string>(),
            SourceColumns = new List<string>()
        };
    }

    #region Public API Methods

    /// <summary>
    /// Generate business context using AutoGenerationRequest (Public API)
    /// </summary>
    public async Task<AutoGenerationResponse> GenerateBusinessContextAsync(AutoGenerationRequest request, string userId)
    {
        return await GenerateBusinessContextInternalAsync(request, userId);
    }

    #endregion

    #region Missing Interface Method Implementation

    /// <summary>
    /// Generate context (IBusinessContextAutoGenerator interface)
    /// </summary>
    public async Task<BusinessContext> GenerateContextAsync(string domain, CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("🤖 Generating business context for domain: {Domain}", domain);

            // Use the existing auto-generation logic
            var request = new AutoGenerationRequest
            {
                GenerateTableContexts = true,
                GenerateGlossaryTerms = true,
                GenerateRelationships = true,
                SpecificTables = null // Generate for all tables
            };

            var response = await GenerateBusinessContextInternalAsync(request, "system");

            return new BusinessContext
            {
                Domain = domain,
                Description = $"Auto-generated business context for {domain}",
                Tables = response.GeneratedTableContexts.Select(t => new BIReportingCopilot.Core.Models.Business.BusinessTable
                {
                    Name = t.TableName,
                    Schema = t.SchemaName,
                    BusinessPurpose = t.BusinessPurpose,
                    BusinessContext = t.BusinessContext
                }).ToList(),
                Terms = response.GeneratedGlossaryTerms.Select(g => new BIReportingCopilot.Core.Models.Business.BusinessTerm
                {
                    Term = g.Term,
                    Definition = g.Definition,
                    BusinessContext = g.BusinessContext
                }).ToList(),
                Relationships = response.RelationshipAnalysis?.Relationships.Select(r => new BIReportingCopilot.Core.Models.Business.BusinessRelationship
                {
                    SourceTable = r.FromTable,
                    TargetTable = r.ToTable,
                    RelationshipType = r.RelationshipType,
                    BusinessDescription = r.BusinessRelationship
                }).ToList() ?? new List<BIReportingCopilot.Core.Models.Business.BusinessRelationship>(),
                GeneratedAt = DateTime.UtcNow
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "❌ Error generating business context for domain: {Domain}", domain);
            return new BusinessContext
            {
                Domain = domain,
                Description = "Error generating context",
                GeneratedAt = DateTime.UtcNow
            };
        }
    }

    /// <summary>
    /// Generate context from schema async (IBusinessContextAutoGenerator interface)
    /// </summary>
    public async Task<BusinessContext> GenerateContextFromSchemaAsync(SchemaMetadata schema, CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("🏗️ Generating business context from schema with {TableCount} tables", schema.Tables?.Count ?? 0);

            var domain = InferDomainFromSchema(schema);
            return await GenerateContextAsync(domain, cancellationToken);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "❌ Error generating context from schema");
            return new BusinessContext
            {
                Domain = "Unknown",
                Description = "Auto-generated context from schema",
                GeneratedAt = DateTime.UtcNow
            };
        }
    }

    /// <summary>
    /// Get available contexts async (IBusinessContextAutoGenerator interface)
    /// </summary>
    public async Task<List<BusinessContext>> GetAvailableContextsAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("📋 Getting available business contexts");

            // Return predefined contexts for common business domains
            return new List<BusinessContext>
            {
                await GenerateContextAsync("gaming", cancellationToken),
                await GenerateContextAsync("finance", cancellationToken),
                await GenerateContextAsync("retail", cancellationToken),
                await GenerateContextAsync("healthcare", cancellationToken),
                await GenerateContextAsync("education", cancellationToken)
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "❌ Error getting available contexts");
            return new List<BusinessContext>();
        }
    }

    private string InferDomainFromSchema(SchemaMetadata schema)
    {
        var tableNames = schema.Tables?.Select(t => t.Name.ToLower()).ToList() ?? new List<string>();

        if (tableNames.Any(t => t.Contains("player") || t.Contains("game") || t.Contains("bet")))
            return "gaming";
        if (tableNames.Any(t => t.Contains("transaction") || t.Contains("payment") || t.Contains("account")))
            return "finance";
        if (tableNames.Any(t => t.Contains("product") || t.Contains("order") || t.Contains("customer")))
            return "retail";
        if (tableNames.Any(t => t.Contains("patient") || t.Contains("medical") || t.Contains("treatment")))
            return "healthcare";
        if (tableNames.Any(t => t.Contains("student") || t.Contains("course") || t.Contains("grade")))
            return "education";

        return "general";
    }

    /// <summary>
    /// Generate table context async (IBusinessContextAutoGenerator interface)
    /// </summary>
    public async Task<BusinessContext> GenerateTableContextAsync(string tableName, SchemaMetadata schema, CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("🔍 Generating table context for: {TableName}", tableName);

            // Find the table in schema
            var table = schema.Tables.FirstOrDefault(t => t.Name.Equals(tableName, StringComparison.OrdinalIgnoreCase));
            if (table == null)
            {
                throw new ArgumentException($"Table '{tableName}' not found in schema");
            }

            // Generate business context using AI
            var prompt = $"Generate business context for table '{tableName}' with columns: {string.Join(", ", table.Columns.Select(c => c.Name))}";
            var aiResponse = await _aiService.GenerateSQLAsync(prompt);

            return new BusinessContext
            {
                Domain = tableName,
                Description = ExtractDescription(aiResponse),
                GeneratedAt = DateTime.UtcNow,
                Tables = new List<BIReportingCopilot.Core.Models.Business.BusinessTable>
                {
                    new BIReportingCopilot.Core.Models.Business.BusinessTable
                    {
                        Name = tableName,
                        BusinessPurpose = ExtractBusinessName(aiResponse),
                        BusinessContext = ExtractDescription(aiResponse)
                    }
                }
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "❌ Error generating table context for: {TableName}", tableName);
            throw;
        }
    }

    /// <summary>
    /// Generate table contexts async (IBusinessContextAutoGenerator interface)
    /// </summary>
    public async Task<List<BusinessContext>> GenerateTableContextsAsync(List<string> tableNames, SchemaMetadata schema, CancellationToken cancellationToken = default)
    {
        var contexts = new List<BusinessContext>();

        foreach (var tableName in tableNames)
        {
            try
            {
                var context = await GenerateTableContextAsync(tableName, schema, cancellationToken);
                contexts.Add(context);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "❌ Error generating context for table: {TableName}", tableName);
                // Continue with other tables
            }
        }

        return contexts;
    }

    /// <summary>
    /// Generate glossary terms async (IBusinessContextAutoGenerator interface)
    /// </summary>
    public async Task<List<BusinessTerm>> GenerateGlossaryTermsAsync(SchemaMetadata schema, CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("📚 Generating glossary terms for schema");

            var terms = new List<BusinessTerm>();

            // Generate terms for each table
            foreach (var table in schema.Tables)
            {
                var prompt = $"Generate business glossary terms for table '{table.Name}' and its columns";
                var aiResponse = await _aiService.GenerateSQLAsync(prompt);

                // Parse AI response and create terms
                var tableTerm = new BusinessTerm
                {
                    Term = table.Name,
                    Definition = ExtractDefinition(aiResponse),
                    Category = "Table"
                };
                terms.Add(tableTerm);
            }

            return terms;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "❌ Error generating glossary terms");
            throw;
        }
    }

    /// <summary>
    /// Analyze table relationships async (IBusinessContextAutoGenerator interface)
    /// </summary>
    public async Task<List<BusinessRelationship>> AnalyzeTableRelationshipsAsync(SchemaMetadata schema, CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("🔗 Analyzing table relationships");

            var relationships = new List<BusinessRelationship>();

            // Analyze foreign key relationships
            foreach (var table in schema.Tables)
            {
                foreach (var column in table.Columns.Where(c => c.IsForeignKey))
                {
                    var relationship = new BusinessRelationship
                    {
                        SourceTable = table.Name,
                        TargetTable = "Unknown", // TODO: Add foreign key table detection
                        RelationshipType = "Foreign Key",
                        Description = $"{table.Name} has foreign key relationship"
                    };
                    relationships.Add(relationship);
                }
            }

            return relationships;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "❌ Error analyzing table relationships");
            throw;
        }
    }

    /// <summary>
    /// Generate business context internal async
    /// </summary>
    private async Task<AutoGenerationResponse> GenerateBusinessContextInternalAsync(AutoGenerationRequest request, string userId)
    {
        try
        {
            _logger.LogInformation("🤖 Generating business context for user: {UserId}", userId);

            var response = new AutoGenerationResponse
            {
                GeneratedTableContexts = new List<AutoGeneratedTableContext>(),
                GeneratedGlossaryTerms = new List<AutoGeneratedGlossaryTerm>(),
                RelationshipAnalysis = new BusinessRelationshipAnalysis
                {
                    Relationships = new List<TableRelationship>()
                }
            };

            // Generate table contexts if requested
            if (request.GenerateTableContexts)
            {
                response.GeneratedTableContexts = await GenerateTableContextsAsync();
            }

            // Generate glossary terms if requested
            if (request.GenerateGlossaryTerms)
            {
                response.GeneratedGlossaryTerms = await GenerateGlossaryTermsAsync();
            }

            return response;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "❌ Error generating business context");
            throw;
        }
    }

    #region Helper Methods

    private string ExtractBusinessName(string aiResponse)
    {
        // Simple extraction logic - in real implementation, use more sophisticated parsing
        return aiResponse.Split('\n').FirstOrDefault()?.Trim() ?? "Unknown";
    }

    private string ExtractDescription(string aiResponse)
    {
        // Simple extraction logic
        return aiResponse.Length > 100 ? aiResponse.Substring(0, 100) + "..." : aiResponse;
    }

    private string ExtractCategory(string aiResponse)
    {
        // Simple categorization logic
        if (aiResponse.ToLower().Contains("player")) return "Player Data";
        if (aiResponse.ToLower().Contains("transaction")) return "Financial";
        if (aiResponse.ToLower().Contains("game")) return "Gaming";
        return "General";
    }

    private List<string> ExtractTags(string aiResponse)
    {
        // Simple tag extraction
        var tags = new List<string>();
        if (aiResponse.ToLower().Contains("daily")) tags.Add("daily");
        if (aiResponse.ToLower().Contains("action")) tags.Add("action");
        if (aiResponse.ToLower().Contains("player")) tags.Add("player");
        return tags;
    }

    private string ExtractDefinition(string aiResponse)
    {
        // Simple definition extraction
        return aiResponse.Split('.').FirstOrDefault()?.Trim() ?? "No definition available";
    }

    #endregion

    #region AI Service Helper Methods

    /// <summary>
    /// Generate structured response using AI service with proper JSON formatting
    /// </summary>
    private async Task<string> GenerateStructuredResponseAsync(string prompt)
    {
        try
        {
            // Enhanced prompt with explicit JSON instructions
            var enhancedPrompt = $@"{prompt}

CRITICAL INSTRUCTIONS:
- Respond with ONLY valid JSON
- Do not include any explanatory text before or after the JSON
- Do not use markdown formatting or code blocks
- Start your response with {{ and end with }}
- Ensure all JSON strings are properly quoted
- Use double quotes for all JSON keys and string values";

            // Use the insight generation method which is better for business analysis
            _logger.LogDebug("🤖 Sending business analysis prompt to AI service");
            var response = await _aiService.GenerateInsightAsync(enhancedPrompt, string.Empty);

            _logger.LogDebug("🤖 Raw AI Response: {Response}", response);

            return response;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating structured AI response");
            throw;
        }
    }

    #endregion

    #endregion
}
