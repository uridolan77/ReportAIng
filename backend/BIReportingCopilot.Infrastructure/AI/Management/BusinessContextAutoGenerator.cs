using BIReportingCopilot.Core.Interfaces;
using BIReportingCopilot.Core.Interfaces.AI;
using BIReportingCopilot.Core.Interfaces.Business;
using BIReportingCopilot.Core.Interfaces.Query;
using BIReportingCopilot.Core.Interfaces.Schema;
using BIReportingCopilot.Core.Interfaces.Messaging;
using BIReportingCopilot.Core.Models;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;

namespace BIReportingCopilot.Infrastructure.AI.Management;

public class BusinessContextAutoGenerator : IBusinessContextAutoGenerator
{
    private readonly ISchemaService _schemaService;
    private readonly IAIService _aiService;
    private readonly ILogger<BusinessContextAutoGenerator> _logger;
    private readonly IServiceProvider _serviceProvider;
    private readonly IProgressHub? _progressHub;

    // Component services
    private readonly TableContextGenerator _tableContextGenerator;
    private readonly GlossaryTermGenerator _glossaryTermGenerator;
    private readonly ColumnContextGenerator _columnContextGenerator;
    private readonly ProgressReporter _progressReporter;
    private readonly AIServiceHelper _aiServiceHelper;

    // Gaming/Casino domain knowledge for confidence scoring
    private readonly Dictionary<string, string> _domainPatterns = new()
    {
        ["player"] = "Gaming customer or user account",
        ["deposit"] = "Money added to player account",
        ["withdrawal"] = "Money removed from player account",
        ["bet"] = "Wager placed by player",
        ["win"] = "Amount won by player",
        ["bonus"] = "Promotional credit given to player",
        ["game"] = "Casino game or slot machine",
        ["session"] = "Gaming session or login period",
        ["transaction"] = "Financial transaction",
        ["balance"] = "Account balance or available funds",
        ["currency"] = "Money denomination",
        ["country"] = "Geographic location",
        ["whitelabel"] = "Brand or operator",
        ["casino"] = "Casino gaming platform",
        ["sport"] = "Sports betting platform",
        ["live"] = "Live dealer games",
        ["bingo"] = "Bingo gaming platform"
    };

    public BusinessContextAutoGenerator(
        ISchemaService schemaService,
        IAIService aiService,
        ILogger<BusinessContextAutoGenerator> logger,
        IServiceProvider serviceProvider)
    {
        _schemaService = schemaService;
        _aiService = aiService;
        _logger = logger;
        _serviceProvider = serviceProvider;
        _progressHub = serviceProvider.GetService<IProgressHub>();

        // Initialize component services
        _aiServiceHelper = new AIServiceHelper(serviceProvider, serviceProvider.GetRequiredService<ILogger<AIServiceHelper>>());
        _progressReporter = new ProgressReporter(_progressHub, serviceProvider.GetRequiredService<ILogger<ProgressReporter>>());
        _tableContextGenerator = new TableContextGenerator(schemaService, aiService, serviceProvider.GetRequiredService<ILogger<TableContextGenerator>>(), _aiServiceHelper);
        _glossaryTermGenerator = new GlossaryTermGenerator(schemaService, aiService, serviceProvider.GetRequiredService<ILogger<GlossaryTermGenerator>>(), _aiServiceHelper);
        _columnContextGenerator = new ColumnContextGenerator(schemaService, aiService, serviceProvider.GetRequiredService<ILogger<ColumnContextGenerator>>(), _aiServiceHelper);
    }

    public async Task<List<AutoGeneratedTableContext>> GenerateTableContextsAsync()
    {
        return await _tableContextGenerator.GenerateTableContextsAsync(null);
    }

    public async Task<List<AutoGeneratedTableContext>> GenerateTableContextsAsync(Func<string, string, string?, Task>? progressCallback = null)
    {
        return await _tableContextGenerator.GenerateTableContextsAsync(progressCallback);
    }

    public async Task<AutoGeneratedTableContext> GenerateTableContextAsync(string tableName, string schemaName)
    {
        return await _tableContextGenerator.GenerateTableContextAsync(tableName, schemaName, null, false);
    }

    public async Task<AutoGeneratedTableContext> GenerateTableContextAsync(string tableName, string schemaName, Func<string, string, string?, Task>? progressCallback = null)
    {
        return await _tableContextGenerator.GenerateTableContextAsync(tableName, schemaName, progressCallback, false);
    }

    public async Task<AutoGeneratedTableContext> GenerateTableContextAsync(string tableName, string schemaName, Func<string, string, string?, Task>? progressCallback = null, bool mockMode = false)
    {
        var context = await _tableContextGenerator.GenerateTableContextAsync(tableName, schemaName, progressCallback, mockMode);

        // Add column contexts and relationships
        var tableMetadata = await _schemaService.GetTableMetadataAsync(tableName, schemaName);
        if (tableMetadata != null)
        {
            if (progressCallback != null)
                await progressCallback("Column Analysis", $"Analyzing {tableMetadata.Columns.Count} columns...", null);

            // Generate column contexts with progress reporting
            context.Columns = await _columnContextGenerator.GenerateColumnContextsAsync(tableMetadata, progressCallback, mockMode);

            if (progressCallback != null)
                await progressCallback("Relationship Analysis", $"Finding related tables for {schemaName}.{tableName}...", null);

            // Analyze relationships
            context.RelatedTables = await FindRelatedTablesAsync(tableMetadata);

            if (progressCallback != null)
                await progressCallback("Finalization", $"Calculating confidence score for {schemaName}.{tableName}...", null);

            // Calculate confidence score
            context.ConfidenceScore = CalculateTableConfidenceScore(context, tableMetadata);
        }

        return context;
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsAsync()
    {
        return await _glossaryTermGenerator.GenerateGlossaryTermsAsync();
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsAsync(List<string> specificTables)
    {
        return await _glossaryTermGenerator.GenerateGlossaryTermsAsync(specificTables, null, false);
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsAsync(List<string> specificTables, Func<string, string, string?, Task>? progressCallback = null)
    {
        return await _glossaryTermGenerator.GenerateGlossaryTermsAsync(specificTables, progressCallback, false);
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsAsync(List<string>? specificTables = null, Func<string, string, string?, Task>? progressCallback = null, bool mockMode = false)
    {
        return await _glossaryTermGenerator.GenerateGlossaryTermsAsync(specificTables, progressCallback, mockMode);
    }

    public async Task<List<AutoGeneratedGlossaryTerm>> GenerateColumnGlossaryAsync(string tableName, string schemaName)
    {
        return await _glossaryTermGenerator.GenerateColumnGlossaryAsync(tableName, schemaName);
    }

    public async Task<BusinessRelationshipAnalysis> AnalyzeTableRelationshipsAsync()
    {
        _logger.LogInformation("Starting table relationship analysis");

        try
        {
            var schema = await _schemaService.GetSchemaMetadataAsync();
            var analysis = new BusinessRelationshipAnalysis();

            // Analyze foreign key relationships
            analysis.Relationships = await AnalyzeForeignKeyRelationships(schema);

            // Identify business domains
            analysis.BusinessDomains = IdentifyBusinessDomains(schema);

            // Analyze data flows
            analysis.DataFlows = AnalyzeDataFlows(schema, analysis.Relationships);

            // Calculate overall confidence
            analysis.OverallConfidence = CalculateRelationshipConfidence(analysis);

            _logger.LogInformation("Completed relationship analysis with {RelCount} relationships, {DomainCount} domains",
                analysis.Relationships.Count, analysis.BusinessDomains.Count);

            return analysis;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in AnalyzeTableRelationshipsAsync");
            throw;
        }
    }

    // These methods are now handled by the TableContextGenerator component

    // These methods are now handled by the GlossaryTermGenerator component

    // Delegate to the column context generator component

    private async Task<List<string>> FindRelatedTablesAsync(TableMetadata table)
    {
        var relatedTables = new List<string>();

        try
        {
            var schema = await _schemaService.GetSchemaMetadataAsync();

            // Find tables with similar naming patterns
            var tableNameParts = ExtractBusinessTerms(table.Name);

            foreach (var otherTable in schema.Tables.Where(t => t.Name != table.Name))
            {
                var otherNameParts = ExtractBusinessTerms(otherTable.Name);
                var commonTerms = tableNameParts.Intersect(otherNameParts, StringComparer.OrdinalIgnoreCase).Count();

                if (commonTerms > 0)
                {
                    relatedTables.Add($"{otherTable.Schema}.{otherTable.Name}");
                }
            }

            // Find tables with foreign key relationships
            foreach (var column in table.Columns.Where(c => c.IsForeignKey))
            {
                // Simple heuristic: look for tables with similar column names
                var potentialReferences = schema.Tables
                    .Where(t => t.Columns.Any(c => c.Name.Equals(column.Name, StringComparison.OrdinalIgnoreCase) && c.IsPrimaryKey))
                    .Select(t => $"{t.Schema}.{t.Name}")
                    .ToList();

                relatedTables.AddRange(potentialReferences);
            }

            return relatedTables.Distinct().ToList();
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error finding related tables for {Table}", table.Name);
            return relatedTables;
        }
    }

    // This method is now handled by the GlossaryTermGenerator component





    private Task<List<TableRelationship>> AnalyzeForeignKeyRelationships(SchemaMetadata schema)
    {
        var relationships = new List<TableRelationship>();

        foreach (var table in schema.Tables)
        {
            foreach (var column in table.Columns.Where(c => c.IsForeignKey))
            {
                // Find potential referenced tables
                var referencedTables = schema.Tables
                    .Where(t => t.Columns.Any(c => c.Name.Equals(column.Name, StringComparison.OrdinalIgnoreCase) && c.IsPrimaryKey))
                    .ToList();

                foreach (var referencedTable in referencedTables)
                {
                    var relationship = new TableRelationship
                    {
                        FromTable = table.Name,
                        FromSchema = table.Schema,
                        ToTable = referencedTable.Name,
                        ToSchema = referencedTable.Schema,
                        RelationshipType = "ManyToOne",
                        BusinessRelationship = GenerateBusinessRelationship(table.Name, referencedTable.Name),
                        ColumnMappings = new List<ColumnMapping>
                        {
                            new ColumnMapping
                            {
                                FromColumn = column.Name,
                                ToColumn = column.Name,
                                BusinessMeaning = GenerateColumnRelationshipMeaning(column.Name, table.Name, referencedTable.Name)
                            }
                        },
                        ConfidenceScore = 0.8
                    };

                    relationships.Add(relationship);
                }
            }
        }

        return Task.FromResult(relationships);
    }

    private List<BusinessDomain> IdentifyBusinessDomains(SchemaMetadata schema)
    {
        var domains = new List<BusinessDomain>();

        // Gaming domain patterns
        var gamingPatterns = new Dictionary<string, List<string>>
        {
            ["Player Management"] = new() { "player", "user", "account", "profile" },
            ["Financial Transactions"] = new() { "deposit", "withdrawal", "transaction", "payment", "balance" },
            ["Gaming Activity"] = new() { "bet", "win", "game", "session", "play" },
            ["Bonus System"] = new() { "bonus", "promotion", "reward", "campaign" },
            ["Platform Management"] = new() { "whitelabel", "brand", "operator", "config" },
            ["Geographic Data"] = new() { "country", "region", "currency", "locale" }
        };

        foreach (var pattern in gamingPatterns)
        {
            var matchingTables = schema.Tables
                .Where(t => pattern.Value.Any(keyword =>
                    t.Name.ToLowerInvariant().Contains(keyword) ||
                    t.Columns.Any(c => c.Name.ToLowerInvariant().Contains(keyword))))
                .Select(t => $"{t.Schema}.{t.Name}")
                .ToList();

            if (matchingTables.Any())
            {
                domains.Add(new BusinessDomain
                {
                    DomainName = pattern.Key,
                    Description = $"Tables related to {pattern.Key.ToLowerInvariant()} in the gaming platform",
                    Tables = matchingTables,
                    KeyConcepts = pattern.Value,
                    ConfidenceScore = 0.7
                });
            }
        }

        return domains;
    }

    private List<DataFlow> AnalyzeDataFlows(SchemaMetadata schema, List<TableRelationship> relationships)
    {
        var dataFlows = new List<DataFlow>();

        // Common gaming data flows
        var commonFlows = new Dictionary<string, (string process, List<string> sequence)>
        {
            ["Player Registration"] = ("New player onboarding", new() { "players", "accounts", "profiles" }),
            ["Deposit Process"] = ("Player funding account", new() { "players", "transactions", "balances" }),
            ["Gaming Session"] = ("Player gaming activity", new() { "sessions", "bets", "games", "wins" }),
            ["Withdrawal Process"] = ("Player cashing out", new() { "balances", "withdrawals", "transactions" }),
            ["Bonus Allocation"] = ("Bonus distribution", new() { "bonuses", "players", "balances" })
        };

        foreach (var flow in commonFlows)
        {
            var matchingTables = new List<string>();

            foreach (var tablePattern in flow.Value.sequence)
            {
                var matches = schema.Tables
                    .Where(t => t.Name.ToLowerInvariant().Contains(tablePattern))
                    .Select(t => $"{t.Schema}.{t.Name}")
                    .ToList();

                matchingTables.AddRange(matches);
            }

            if (matchingTables.Count >= 2)
            {
                dataFlows.Add(new DataFlow
                {
                    FlowName = flow.Key,
                    BusinessProcess = flow.Value.process,
                    TableSequence = matchingTables.Distinct().ToList(),
                    Description = $"Data flow for {flow.Value.process} involving {matchingTables.Count} tables",
                    ConfidenceScore = 0.6
                });
            }
        }

        return dataFlows;
    }

    // Helper methods for business context generation
    private string GenerateBusinessName(string technicalName)
    {
        // Convert technical names to business-friendly names
        var name = technicalName.Replace("tbl_", "").Replace("_", " ");

        // Apply domain-specific transformations
        foreach (var pattern in _domainPatterns)
        {
            if (name.ToLowerInvariant().Contains(pattern.Key))
            {
                name = name.Replace(pattern.Key, pattern.Value, StringComparison.OrdinalIgnoreCase);
            }
        }

        return System.Globalization.CultureInfo.CurrentCulture.TextInfo.ToTitleCase(name.ToLowerInvariant());
    }

    private string GenerateColumnDescription(ColumnMetadata column, string tableName)
    {
        var businessName = GenerateBusinessName(column.Name);
        var tableBusinessName = GenerateBusinessName(tableName);

        if (column.IsPrimaryKey)
        {
            return $"Unique identifier for {tableBusinessName}";
        }

        if (column.IsForeignKey)
        {
            return $"Reference to related {businessName} record";
        }

        // Check for common patterns
        var lowerName = column.Name.ToLowerInvariant();
        if (lowerName.Contains("date") || lowerName.Contains("time"))
        {
            return $"Date/time when {businessName} occurred";
        }

        if (lowerName.Contains("amount") || lowerName.Contains("value"))
        {
            return $"Monetary amount for {businessName}";
        }

        if (lowerName.Contains("count") || lowerName.Contains("number"))
        {
            return $"Count or number of {businessName}";
        }

        return $"{businessName} information for {tableBusinessName}";
    }

    private string MapToBusinessDataType(string technicalDataType)
    {
        return technicalDataType.ToLowerInvariant() switch
        {
            var t when t.Contains("varchar") || t.Contains("char") || t.Contains("text") => "Text",
            var t when t.Contains("int") || t.Contains("bigint") => "Number",
            var t when t.Contains("decimal") || t.Contains("money") || t.Contains("float") => "Currency/Decimal",
            var t when t.Contains("date") || t.Contains("time") => "Date/Time",
            var t when t.Contains("bit") || t.Contains("bool") => "Yes/No",
            var t when t.Contains("uniqueidentifier") => "Unique ID",
            _ => "Data"
        };
    }

    private List<string> GenerateColumnBusinessRules(ColumnMetadata column)
    {
        var rules = new List<string>();

        if (!column.IsNullable)
        {
            rules.Add("Required field - cannot be empty");
        }

        if (column.IsPrimaryKey)
        {
            rules.Add("Must be unique across all records");
        }

        var lowerName = column.Name.ToLowerInvariant();
        if (lowerName.Contains("email"))
        {
            rules.Add("Must be valid email format");
        }

        if (lowerName.Contains("amount") || lowerName.Contains("balance"))
        {
            rules.Add("Must be non-negative value");
        }

        if (lowerName.Contains("date"))
        {
            rules.Add("Must be valid date");
        }

        return rules;
    }

    private List<string> GenerateColumnUseCases(ColumnMetadata column, string tableName)
    {
        var useCases = new List<string>();
        var businessName = GenerateBusinessName(column.Name);
        var tableBusinessName = GenerateBusinessName(tableName);

        useCases.Add($"Filter {tableBusinessName} by {businessName}");
        useCases.Add($"Sort {tableBusinessName} by {businessName}");

        var lowerName = column.Name.ToLowerInvariant();
        if (lowerName.Contains("amount") || lowerName.Contains("value"))
        {
            useCases.Add($"Calculate total {businessName}");
            useCases.Add($"Calculate average {businessName}");
        }

        if (lowerName.Contains("date"))
        {
            useCases.Add($"Group by {businessName} period");
            useCases.Add($"Filter by {businessName} range");
        }

        if (lowerName.Contains("count"))
        {
            useCases.Add($"Sum total {businessName}");
        }

        return useCases;
    }

    private List<string> ExtractBusinessTerms(string name)
    {
        // Split on common separators and extract meaningful terms
        var terms = new List<string>();
        var cleanName = name.Replace("tbl_", "").Replace("_", " ");

        // Split on various separators
        var parts = Regex.Split(cleanName, @"[_\s\-\.]+", RegexOptions.IgnoreCase)
            .Where(p => !string.IsNullOrWhiteSpace(p) && p.Length > 1)
            .ToList();

        terms.AddRange(parts);

        // Also try camelCase splitting
        var camelCaseParts = Regex.Split(name, @"(?<!^)(?=[A-Z])", RegexOptions.IgnoreCase)
            .Where(p => !string.IsNullOrWhiteSpace(p) && p.Length > 1)
            .ToList();

        terms.AddRange(camelCaseParts);

        return terms.Distinct(StringComparer.OrdinalIgnoreCase).ToList();
    }

    private string GenerateBusinessRelationship(string fromTable, string toTable)
    {
        var fromBusiness = GenerateBusinessName(fromTable);
        var toBusiness = GenerateBusinessName(toTable);
        return $"{fromBusiness} is related to {toBusiness}";
    }

    private string GenerateColumnRelationshipMeaning(string columnName, string fromTable, string toTable)
    {
        var columnBusiness = GenerateBusinessName(columnName);
        var fromBusiness = GenerateBusinessName(fromTable);
        var toBusiness = GenerateBusinessName(toTable);
        return $"{columnBusiness} links {fromBusiness} to {toBusiness}";
    }

    // Confidence calculation methods
    private double CalculateTableConfidenceScore(AutoGeneratedTableContext context, TableMetadata table)
    {
        double score = 0.5; // Base score

        // Increase confidence based on recognizable patterns
        var lowerTableName = table.Name.ToLowerInvariant();
        foreach (var pattern in _domainPatterns.Keys)
        {
            if (lowerTableName.Contains(pattern))
            {
                score += 0.1;
            }
        }

        // Increase confidence based on column patterns
        var recognizedColumns = table.Columns.Count(c =>
            _domainPatterns.Keys.Any(p => c.Name.ToLowerInvariant().Contains(p)));

        score += (double)recognizedColumns / table.Columns.Count * 0.3;

        // Cap at 0.9 for auto-generated content
        return Math.Min(score, 0.9);
    }

    private double CalculateColumnConfidenceScore(ColumnMetadata column)
    {
        double score = 0.5; // Base score

        var lowerName = column.Name.ToLowerInvariant();

        // Increase confidence for recognized patterns
        foreach (var pattern in _domainPatterns.Keys)
        {
            if (lowerName.Contains(pattern))
            {
                score += 0.2;
                break;
            }
        }

        // Increase confidence for standard patterns
        if (lowerName.Contains("id") || column.IsPrimaryKey || column.IsForeignKey)
            score += 0.1;

        if (lowerName.Contains("date") || lowerName.Contains("time"))
            score += 0.1;

        if (lowerName.Contains("amount") || lowerName.Contains("value"))
            score += 0.1;

        return Math.Min(score, 0.9);
    }

    private double CalculateRelationshipConfidence(BusinessRelationshipAnalysis analysis)
    {
        if (!analysis.Relationships.Any())
            return 0.3;

        var avgRelationshipConfidence = analysis.Relationships.Average(r => r.ConfidenceScore);
        var avgDomainConfidence = analysis.BusinessDomains.Any()
            ? analysis.BusinessDomains.Average(d => d.ConfidenceScore)
            : 0.5;

        return (avgRelationshipConfidence + avgDomainConfidence) / 2;
    }

    // JSON parsing methods are now handled by the JsonHelper component

    // Mock data generation is now handled by the MockDataGenerator component

    // Mock glossary term generation is now handled by the MockDataGenerator component

    #region Public API Methods

    /// <summary>
    /// Generate business context using AutoGenerationRequest (Public API)
    /// </summary>
    public async Task<AutoGenerationResponse> GenerateBusinessContextAsync(AutoGenerationRequest request, string userId)
    {
        try
        {
            // Add timeout to prevent infinite loops
            using var cts = new CancellationTokenSource(TimeSpan.FromMinutes(5));
            return await GenerateBusinessContextInternalAsync(request, userId, cts.Token);
        }
        catch (OperationCanceledException)
        {
            _logger.LogWarning("Auto-generation timed out after 5 minutes for user {UserId}", userId);
            return new AutoGenerationResponse
            {
                Success = false,
                Message = "Auto-generation timed out. Please try with fewer tables or fields.",
                Errors = new List<string> { "Operation timed out after 5 minutes" },
                GeneratedTableContexts = new List<AutoGeneratedTableContext>(),
                GeneratedGlossaryTerms = new List<AutoGeneratedGlossaryTerm>()
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in auto-generation for user {UserId}", userId);
            return new AutoGenerationResponse
            {
                Success = false,
                Message = $"Auto-generation failed: {ex.Message}",
                Errors = new List<string> { ex.Message },
                GeneratedTableContexts = new List<AutoGeneratedTableContext>(),
                GeneratedGlossaryTerms = new List<AutoGeneratedGlossaryTerm>()
            };
        }
    }

    #endregion

    #region Missing Interface Method Implementation

    /// <summary>
    /// Generate context (IBusinessContextAutoGenerator interface)
    /// </summary>
    public async Task<BIReportingCopilot.Core.Models.Business.BusinessContext> GenerateContextAsync(string domain, CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("ü§ñ Generating business context for domain: {Domain}", domain);

            // Use the existing auto-generation logic
            var request = new AutoGenerationRequest
            {
                GenerateTableContexts = true,
                GenerateGlossaryTerms = true,
                GenerateRelationships = true,
                SpecificTables = null // Generate for all tables
            };

            var response = await GenerateBusinessContextInternalAsync(request, "system");

            return new BIReportingCopilot.Core.Models.Business.BusinessContext
            {
                Domain = domain,
                Description = $"Auto-generated business context for {domain}",
                Tables = response.GeneratedTableContexts.Select(t => new BIReportingCopilot.Core.Models.Business.BusinessTable
                {
                    Name = t.TableName,
                    Schema = t.SchemaName,
                    BusinessPurpose = t.BusinessPurpose,
                    BusinessContext = t.BusinessContext
                }).ToList(),
                Terms = response.GeneratedGlossaryTerms.Select(g => new BIReportingCopilot.Core.Models.Business.BusinessTerm
                {
                    Term = g.Term,
                    Definition = g.Definition,
                    BusinessContext = g.BusinessContext
                }).ToList(),
                Relationships = response.RelationshipAnalysis?.Relationships.Select(r => new BIReportingCopilot.Core.Models.Business.BusinessRelationship
                {
                    SourceTable = r.FromTable,
                    TargetTable = r.ToTable,
                    RelationshipType = r.RelationshipType,
                    BusinessDescription = r.BusinessRelationship
                }).ToList() ?? new List<BIReportingCopilot.Core.Models.Business.BusinessRelationship>(),
                GeneratedAt = DateTime.UtcNow
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Error generating business context for domain: {Domain}", domain);
            return new BIReportingCopilot.Core.Models.Business.BusinessContext
            {
                Domain = domain,
                Description = "Error generating context",
                GeneratedAt = DateTime.UtcNow
            };
        }
    }

    /// <summary>
    /// Generate context from schema async (IBusinessContextAutoGenerator interface)
    /// </summary>
    public async Task<BIReportingCopilot.Core.Models.Business.BusinessContext> GenerateContextFromSchemaAsync(SchemaMetadata schema, CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("üèóÔ∏è Generating business context from schema with {TableCount} tables", schema.Tables?.Count ?? 0);

            var domain = InferDomainFromSchema(schema);
            return await GenerateContextAsync(domain, cancellationToken);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Error generating context from schema");
            return new BIReportingCopilot.Core.Models.Business.BusinessContext
            {
                Domain = "Unknown",
                Description = "Auto-generated context from schema",
                GeneratedAt = DateTime.UtcNow
            };
        }
    }

    /// <summary>
    /// Get available contexts async (IBusinessContextAutoGenerator interface)
    /// </summary>
    public async Task<List<BIReportingCopilot.Core.Models.Business.BusinessContext>> GetAvailableContextsAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("üìã Getting available business contexts");

            // Return predefined contexts for common business domains
            return new List<BIReportingCopilot.Core.Models.Business.BusinessContext>
            {
                await GenerateContextAsync("gaming", cancellationToken),
                await GenerateContextAsync("finance", cancellationToken),
                await GenerateContextAsync("retail", cancellationToken),
                await GenerateContextAsync("healthcare", cancellationToken),
                await GenerateContextAsync("education", cancellationToken)
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Error getting available contexts");
            return new List<BIReportingCopilot.Core.Models.Business.BusinessContext>();
        }
    }

    private string InferDomainFromSchema(SchemaMetadata schema)
    {
        var tableNames = schema.Tables?.Select(t => t.Name.ToLower()).ToList() ?? new List<string>();

        if (tableNames.Any(t => t.Contains("player") || t.Contains("game") || t.Contains("bet")))
            return "gaming";
        if (tableNames.Any(t => t.Contains("transaction") || t.Contains("payment") || t.Contains("account")))
            return "finance";
        if (tableNames.Any(t => t.Contains("product") || t.Contains("order") || t.Contains("customer")))
            return "retail";
        if (tableNames.Any(t => t.Contains("patient") || t.Contains("medical") || t.Contains("treatment")))
            return "healthcare";
        if (tableNames.Any(t => t.Contains("student") || t.Contains("course") || t.Contains("grade")))
            return "education";

        return "general";
    }

    /// <summary>
    /// Generate table context async (IBusinessContextAutoGenerator interface)
    /// </summary>
    public async Task<BIReportingCopilot.Core.Models.Business.BusinessContext> GenerateTableContextAsync(string tableName, SchemaMetadata schema, CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("üîç Generating table context for: {TableName}", tableName);

            // Find the table in schema
            var table = schema.Tables.FirstOrDefault(t => t.Name.Equals(tableName, StringComparison.OrdinalIgnoreCase));
            if (table == null)
            {
                throw new ArgumentException($"Table '{tableName}' not found in schema");
            }

            // Generate business context using AI
            var prompt = $"Generate business context for table '{tableName}' with columns: {string.Join(", ", table.Columns.Select(c => c.Name))}";
            var aiResponse = await _aiService.GenerateSQLAsync(prompt);

            return new BIReportingCopilot.Core.Models.Business.BusinessContext
            {
                Domain = tableName,
                Description = ExtractDescription(aiResponse),
                GeneratedAt = DateTime.UtcNow,
                Tables = new List<BIReportingCopilot.Core.Models.Business.BusinessTable>
                {
                    new BIReportingCopilot.Core.Models.Business.BusinessTable
                    {
                        Name = tableName,
                        BusinessPurpose = ExtractBusinessName(aiResponse),
                        BusinessContext = ExtractDescription(aiResponse)
                    }
                }
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Error generating table context for: {TableName}", tableName);
            throw;
        }
    }

    /// <summary>
    /// Generate table contexts async (IBusinessContextAutoGenerator interface)
    /// </summary>
    public async Task<List<BIReportingCopilot.Core.Models.Business.BusinessContext>> GenerateTableContextsAsync(List<string> tableNames, SchemaMetadata schema, CancellationToken cancellationToken = default)
    {
        var contexts = new List<BIReportingCopilot.Core.Models.Business.BusinessContext>();

        foreach (var tableName in tableNames)
        {
            try
            {
                var context = await GenerateTableContextAsync(tableName, schema, cancellationToken);
                contexts.Add(context);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Error generating context for table: {TableName}", tableName);
                // Continue with other tables
            }
        }

        return contexts;
    }

    /// <summary>
    /// Generate glossary terms async (IBusinessContextAutoGenerator interface)
    /// </summary>
    public async Task<List<BIReportingCopilot.Core.Models.Business.BusinessTerm>> GenerateGlossaryTermsAsync(SchemaMetadata schema, CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("üìö Generating glossary terms for schema");

            var terms = new List<BIReportingCopilot.Core.Models.Business.BusinessTerm>();

            // Generate terms for each table
            foreach (var table in schema.Tables)
            {
                var prompt = $"Generate business glossary terms for table '{table.Name}' and its columns";
                var aiResponse = await _aiService.GenerateSQLAsync(prompt);

                // Parse AI response and create terms
                var tableTerm = new BIReportingCopilot.Core.Models.Business.BusinessTerm
                {
                    Term = table.Name,
                    Definition = ExtractDefinition(aiResponse),
                    Category = "Table"
                };
                terms.Add(tableTerm);
            }

            return terms;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Error generating glossary terms");
            throw;
        }
    }

    /// <summary>
    /// Analyze table relationships async (IBusinessContextAutoGenerator interface)
    /// </summary>
    public async Task<List<BIReportingCopilot.Core.Models.Business.BusinessRelationship>> AnalyzeTableRelationshipsAsync(SchemaMetadata schema, CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("üîó Analyzing table relationships");

            var relationships = new List<BIReportingCopilot.Core.Models.Business.BusinessRelationship>();

            // Analyze foreign key relationships
            foreach (var table in schema.Tables)
            {
                foreach (var column in table.Columns.Where(c => c.IsForeignKey))
                {
                    var relationship = new BIReportingCopilot.Core.Models.Business.BusinessRelationship
                    {
                        SourceTable = table.Name,
                        TargetTable = "Unknown", // TODO: Add foreign key table detection
                        RelationshipType = "Foreign Key",
                        BusinessDescription = $"{table.Name} has foreign key relationship"
                    };
                    relationships.Add(relationship);
                }
            }

            return relationships;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Error analyzing table relationships");
            throw;
        }
    }

    /// <summary>
    /// Generate business context internal async
    /// </summary>
    private async Task<AutoGenerationResponse> GenerateBusinessContextInternalAsync(AutoGenerationRequest request, string userId, CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("ü§ñ Generating business context for user: {UserId}", userId);
            _logger.LogInformation("ü§ñ Request details: GenerateTableContexts={GenerateTableContexts}, GenerateGlossaryTerms={GenerateGlossaryTerms}",
                request.GenerateTableContexts, request.GenerateGlossaryTerms);
            _logger.LogInformation("ü§ñ Specific tables: {SpecificTables}",
                request.SpecificTables != null ? string.Join(", ", request.SpecificTables) : "None");

            // Send initial progress update
            if (_progressHub != null)
            {
                await _progressHub.SendProgressUpdateAsync(userId, "auto-generation", 0, "Starting auto-generation process...");
            }

            // Test AI service availability first
            try
            {
                if (_progressHub != null)
                {
                    await _progressHub.SendProgressUpdateAsync(userId, "auto-generation", 5, "Checking AI service availability...");
                }

                var isHealthy = await _aiService.IsHealthyAsync(cancellationToken);
                _logger.LogInformation("ü§ñ AI Service health check: {IsHealthy}", isHealthy);

                if (!isHealthy)
                {
                    _logger.LogWarning("‚ö†Ô∏è AI Service is not healthy - auto-generation may fail");
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Error checking AI service health");
            }

            if (_progressHub != null)
            {
                await _progressHub.SendProgressUpdateAsync(userId, "auto-generation", 10, "Initializing auto-generation response...");
            }

            var response = new AutoGenerationResponse
            {
                GeneratedTableContexts = new List<AutoGeneratedTableContext>(),
                GeneratedGlossaryTerms = new List<AutoGeneratedGlossaryTerm>(),
                RelationshipAnalysis = new BusinessRelationshipAnalysis
                {
                    Relationships = new List<TableRelationship>()
                }
            };

            // Generate table contexts if requested
            if (request.GenerateTableContexts)
            {
                try
                {
                    if (_progressHub != null)
                    {
                        await _progressHub.SendProgressUpdateAsync(userId, "auto-generation", 20, "Starting table context generation...");
                    }

                    if (request.SpecificTables?.Any() == true)
                    {
                        _logger.LogInformation("üéØ Generating contexts for {Count} specific tables: {Tables}",
                            request.SpecificTables.Count, string.Join(", ", request.SpecificTables));

                        response.GeneratedTableContexts = await GenerateSpecificTableContextsWithProgressAsync(request.SpecificTables, request.SpecificFields, userId);
                    }
                    else
                    {
                        _logger.LogInformation("üåê Generating contexts for all tables");
                        response.GeneratedTableContexts = await GenerateTableContextsWithProgressAsync(userId);
                    }

                    if (_progressHub != null)
                    {
                        await _progressHub.SendProgressUpdateAsync(userId, "auto-generation", 60, $"Generated {response.GeneratedTableContexts.Count} table contexts");
                    }

                    _logger.LogInformation("‚úÖ Generated {Count} table contexts", response.GeneratedTableContexts.Count);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "‚ùå Error generating table contexts");
                    response.GeneratedTableContexts = new List<AutoGeneratedTableContext>();
                    response.Warnings.Add("Failed to generate table contexts due to AI service error");
                }
            }

            // Generate glossary terms if requested
            if (request.GenerateGlossaryTerms)
            {
                try
                {
                    if (_progressHub != null)
                    {
                        await _progressHub.SendProgressUpdateAsync(userId, "auto-generation", 70, "Starting glossary term generation...");
                    }

                    if (request.SpecificTables?.Any() == true)
                    {
                        _logger.LogInformation("üìö Generating glossary terms for {Count} specific tables: {Tables}",
                            request.SpecificTables.Count, string.Join(", ", request.SpecificTables));
                        response.GeneratedGlossaryTerms = await GenerateGlossaryTermsWithProgressAsync(request.SpecificTables, userId);
                    }
                    else
                    {
                        _logger.LogInformation("üìö Generating glossary terms for all tables");
                        response.GeneratedGlossaryTerms = await GenerateGlossaryTermsWithProgressAsync(null, userId);
                    }

                    if (_progressHub != null)
                    {
                        await _progressHub.SendProgressUpdateAsync(userId, "auto-generation", 85, $"Generated {response.GeneratedGlossaryTerms.Count} glossary terms");
                    }

                    _logger.LogInformation("‚úÖ Generated {Count} glossary terms", response.GeneratedGlossaryTerms.Count);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "‚ùå Error generating glossary terms");
                    response.GeneratedGlossaryTerms = new List<AutoGeneratedGlossaryTerm>();
                    response.Warnings.Add("Failed to generate glossary terms due to AI service error");
                }
            }
            else
            {
                response.GeneratedGlossaryTerms = new List<AutoGeneratedGlossaryTerm>();
            }

            if (_progressHub != null)
            {
                await _progressHub.SendProgressUpdateAsync(userId, "auto-generation", 95, "Finalizing auto-generation results...");
            }

            // Set success status and summary
            response.Success = true;
            response.Message = $"Successfully generated contexts for {response.GeneratedTableContexts.Count} tables and {response.GeneratedGlossaryTerms.Count} glossary terms";
            response.TotalTablesProcessed = response.GeneratedTableContexts.Count;
            response.TotalTermsGenerated = response.GeneratedGlossaryTerms.Count;

            if (_progressHub != null)
            {
                await _progressHub.SendProgressUpdateAsync(userId, "auto-generation", 100, response.Message);
            }

            _logger.LogInformation("üéâ Auto-generation completed successfully: {Message}", response.Message);

            return response;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Error generating business context");
            throw;
        }
    }

    /// <summary>
    /// Generate contexts for specific selected tables and fields with progress reporting
    /// </summary>
    private async Task<List<AutoGeneratedTableContext>> GenerateSpecificTableContextsWithProgressAsync(
        List<string> specificTables,
        Dictionary<string, List<string>>? specificFields,
        string userId)
    {
        var results = new List<AutoGeneratedTableContext>();

        try
        {
            _logger.LogInformation("üéØ Starting targeted auto-generation for {Count} specific tables", specificTables.Count);

            // Get schema metadata
            var schema = await _schemaService.GetSchemaMetadataAsync();

            var processedTables = 0;
            foreach (var tableName in specificTables)
            {
                try
                {
                    if (_progressHub != null)
                    {
                        var progress = 20 + (int)((double)processedTables / specificTables.Count * 40); // 20-60% range
                        await _progressHub.SendProgressUpdateAsync(userId, "auto-generation", progress, $"Processing table {tableName} ({processedTables + 1}/{specificTables.Count})");
                    }

                    _logger.LogInformation("üîç Processing table: {TableName}", tableName);

                    // Get the selected fields for this table
                    var selectedFieldNames = specificFields?.ContainsKey(tableName) == true
                        ? specificFields[tableName]
                        : new List<string>();

                    _logger.LogInformation("üìã Selected {Count} fields for table {TableName}: {Fields}",
                        selectedFieldNames.Count, tableName,
                        string.Join(", ", selectedFieldNames));

                    // Create progress callback for this table
                    var progressCallback = CreateProgressCallback(userId, "Table Processing");

                    // Generate context for this specific table with selected fields
                    var tableContext = await _tableContextGenerator.GenerateTableContextWithFieldsAsync(tableName, selectedFieldNames, schema, userId, progressCallback);

                    if (tableContext != null)
                    {
                        results.Add(tableContext);
                        _logger.LogInformation("‚úÖ Generated context for table: {TableName}", tableName);
                    }

                    processedTables++;
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "‚ùå Error generating context for table: {TableName}", tableName);
                    processedTables++;
                    // Continue with other tables
                }
            }

            _logger.LogInformation("üéâ Completed targeted auto-generation for {ProcessedCount}/{TotalCount} tables",
                results.Count, specificTables.Count);

            return results;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Error in GenerateSpecificTableContextsWithProgressAsync");
            throw;
        }
    }

    /// <summary>
    /// Generate contexts for specific selected tables and fields (legacy method without progress)
    /// </summary>
    private async Task<List<AutoGeneratedTableContext>> GenerateSpecificTableContextsAsync(
        List<string> specificTables,
        Dictionary<string, List<string>>? specificFields = null)
    {
        var results = new List<AutoGeneratedTableContext>();

        try
        {
            _logger.LogInformation("üéØ Starting targeted auto-generation for {Count} specific tables", specificTables.Count);

            // Get schema metadata
            var schema = await _schemaService.GetSchemaMetadataAsync();

            foreach (var tableName in specificTables)
            {
                try
                {
                    _logger.LogInformation("üîç Processing table: {TableName}", tableName);

                    // Get the selected fields for this table
                    var selectedFieldNames = specificFields?.ContainsKey(tableName) == true
                        ? specificFields[tableName]
                        : new List<string>();

                    _logger.LogInformation("üìã Selected {Count} fields for table {TableName}: {Fields}",
                        selectedFieldNames.Count, tableName,
                        string.Join(", ", selectedFieldNames));

                    // Generate context for this specific table with selected fields
                    var tableContext = await GenerateTableContextWithFieldsAsync(tableName, selectedFieldNames, schema);

                    if (tableContext != null)
                    {
                        results.Add(tableContext);
                        _logger.LogInformation("‚úÖ Generated context for table: {TableName}", tableName);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "‚ùå Error generating context for table: {TableName}", tableName);
                    // Continue with other tables
                }
            }

            _logger.LogInformation("üéâ Completed targeted auto-generation for {ProcessedCount}/{TotalCount} tables",
                results.Count, specificTables.Count);

            return results;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Error in GenerateSpecificTableContextsAsync");
            throw;
        }
    }

    /// <summary>
    /// Generate context for a specific table with selected fields
    /// </summary>
    private async Task<AutoGeneratedTableContext> GenerateTableContextWithFieldsAsync(
        string tableName,
        List<string> selectedFieldNames,
        SchemaMetadata schema,
        string? userId = null)
    {
        try
        {
            _logger.LogInformation("üîç Generating context for table {TableName} with {FieldCount} selected fields",
                tableName, selectedFieldNames.Count);

            if (_progressHub != null && !string.IsNullOrEmpty(userId))
            {
                await _progressHub.SendProgressUpdateAsync(userId, "auto-generation", 35, $"Analyzing table structure for {tableName}...");
            }

            // Find the table in schema
            var tableMetadata = schema.Tables.FirstOrDefault(t => t.Name.Equals(tableName, StringComparison.OrdinalIgnoreCase));
            if (tableMetadata == null)
            {
                _logger.LogWarning("‚ö†Ô∏è Table {TableName} not found in schema", tableName);
                return null;
            }

            if (_progressHub != null && !string.IsNullOrEmpty(userId))
            {
                await _progressHub.SendProgressUpdateAsync(userId, "auto-generation", 45, $"Building AI prompt for {tableName}...");
            }

            // Build AI prompt focusing on selected fields
            var prompt = BuildTableContextPromptWithFields(tableMetadata, selectedFieldNames, schema);

            if (_progressHub != null && !string.IsNullOrEmpty(userId))
            {
                await _progressHub.SendProgressUpdateAsync(userId, "auto-generation", 55, $"Sending request to AI service for {tableName}...");
            }

            // Get AI analysis
            var aiResponse = await _aiServiceHelper.GenerateStructuredResponseAsync(prompt);

            if (_progressHub != null && !string.IsNullOrEmpty(userId))
            {
                await _progressHub.SendProgressUpdateAsync(userId, "auto-generation", 65, $"Processing AI response for {tableName}...");
            }

            // Parse the response
            var tableContext = ParseTableContextResponse(aiResponse, tableMetadata, selectedFieldNames);

            _logger.LogDebug("‚úÖ Generated context for {TableName} with {FieldCount} fields",
                tableName, selectedFieldNames.Count);

            return tableContext;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Error generating context for table {TableName}", tableName);
            throw;
        }
    }

    #region Helper Methods

    private string ExtractBusinessName(string aiResponse)
    {
        // Simple extraction logic - in real implementation, use more sophisticated parsing
        return aiResponse.Split('\n').FirstOrDefault()?.Trim() ?? "Unknown";
    }

    private string ExtractDescription(string aiResponse)
    {
        // Simple extraction logic
        return aiResponse.Length > 100 ? aiResponse.Substring(0, 100) + "..." : aiResponse;
    }

    private string ExtractCategory(string aiResponse)
    {
        // Simple categorization logic
        if (aiResponse.ToLower().Contains("player")) return "Player Data";
        if (aiResponse.ToLower().Contains("transaction")) return "Financial";
        if (aiResponse.ToLower().Contains("game")) return "Gaming";
        return "General";
    }

    private List<string> ExtractTags(string aiResponse)
    {
        // Simple tag extraction
        var tags = new List<string>();
        if (aiResponse.ToLower().Contains("daily")) tags.Add("daily");
        if (aiResponse.ToLower().Contains("action")) tags.Add("action");
        if (aiResponse.ToLower().Contains("player")) tags.Add("player");
        return tags;
    }

    private string ExtractDefinition(string aiResponse)
    {
        // Simple definition extraction
        return aiResponse.Split('.').FirstOrDefault()?.Trim() ?? "No definition available";
    }

    /// <summary>
    /// Build AI prompt for table context with specific selected fields
    /// </summary>
    private string BuildTableContextPromptWithFields(TableMetadata tableMetadata, List<string> selectedFieldNames, SchemaMetadata schema)
    {
        var relevantColumns = tableMetadata.Columns.Where(c => selectedFieldNames.Contains(c.Name)).ToList();

        var prompt = $@"Analyze this database table and generate business context focusing on the selected fields:

TABLE: {tableMetadata.Name}
SCHEMA: {tableMetadata.Schema}

SELECTED FIELDS TO FOCUS ON:
{string.Join("\n", selectedFieldNames.Select(f => $"- {f}"))}

COLUMN DETAILS FOR SELECTED FIELDS:
{string.Join("\n", relevantColumns.Select(c => $"- {c.Name}: {c.DataType} {(c.IsNullable ? "(nullable)" : "(required)")} {(c.IsPrimaryKey ? "(PRIMARY KEY)" : "")} {(c.IsForeignKey ? "(FOREIGN KEY)" : "")}"))}

Generate a JSON response with this exact structure:
{{
  ""businessPurpose"": ""Detailed explanation of what this table represents in business terms"",
  ""businessContext"": ""Additional business context and background"",
  ""primaryUseCase"": ""Primary use case for this table"",
  ""confidenceScore"": 0.85,
  ""keyBusinessMetrics"": [""metric1"", ""metric2""],
  ""commonQueryPatterns"": [""pattern1"", ""pattern2""],
  ""businessRules"": ""Business rules that apply to this table"",
  ""columnContexts"": [
    {{
      ""columnName"": ""column_name"",
      ""businessName"": ""Business-friendly name"",
      ""businessDescription"": ""What this field represents in business terms"",
      ""businessDataType"": ""Text/Number/Date/Boolean"",
      ""confidenceScore"": 0.80
    }}
  ]
}}

Focus specifically on the selected fields: {string.Join(", ", selectedFieldNames)}";

        return prompt;
    }

    /// <summary>
    /// Parse table context response with selected fields
    /// </summary>
    private AutoGeneratedTableContext ParseTableContextResponse(string aiResponse, TableMetadata tableMetadata, List<string> selectedFieldNames)
    {
        try
        {
            // Log the raw response for debugging
            _logger.LogInformation("ü§ñ Raw AI response for {TableName}: '{Response}'", tableMetadata.Name, aiResponse);

            // Check if response is empty or null
            if (string.IsNullOrWhiteSpace(aiResponse))
            {
                throw new InvalidOperationException($"AI response is empty for table {tableMetadata.Name}");
            }

            // Clean the response
            var cleanResponse = aiResponse.Trim();
            if (cleanResponse.StartsWith("```json"))
            {
                cleanResponse = cleanResponse.Substring(7);
            }
            if (cleanResponse.EndsWith("```"))
            {
                cleanResponse = cleanResponse.Substring(0, cleanResponse.Length - 3);
            }
            cleanResponse = cleanResponse.Trim();

            // Check if it looks like JSON (starts with { or [)
            if (!cleanResponse.StartsWith("{") && !cleanResponse.StartsWith("["))
            {
                throw new InvalidOperationException($"AI response doesn't appear to be JSON for table {tableMetadata.Name}: '{cleanResponse.Substring(0, Math.Min(100, cleanResponse.Length))}'");
            }

            // Parse JSON
            var jsonDoc = JsonDocument.Parse(cleanResponse);
            var root = jsonDoc.RootElement;

            // Create table context
            var tableContext = new AutoGeneratedTableContext
            {
                TableName = tableMetadata.Name,
                SchemaName = tableMetadata.Schema,
                BusinessPurpose = root.GetProperty("businessPurpose").GetString() ?? "Business purpose not available",
                BusinessContext = root.GetProperty("businessContext").GetString() ?? "Business context not available",
                PrimaryUseCase = root.GetProperty("primaryUseCase").GetString() ?? "Primary use case not available",
                ConfidenceScore = root.GetProperty("confidenceScore").GetDouble(),
                KeyBusinessMetrics = root.TryGetProperty("keyBusinessMetrics", out var metricsElement)
                    ? metricsElement.EnumerateArray().Select(m => m.GetString()).Where(m => !string.IsNullOrEmpty(m)).ToList()
                    : new List<string>(),
                CommonQueryPatterns = root.TryGetProperty("commonQueryPatterns", out var patternsElement)
                    ? patternsElement.EnumerateArray().Select(p => p.GetString()).Where(p => !string.IsNullOrEmpty(p)).ToList()
                    : new List<string>(),
                BusinessRules = root.GetProperty("businessRules").GetString() ?? "Standard business rules apply",
                GeneratedAt = DateTime.UtcNow,
                IsAutoGenerated = true,
                Columns = new List<AutoGeneratedColumnContext>()
            };

            // Parse column contexts for selected fields only
            if (root.TryGetProperty("columnContexts", out var columnContextsElement))
            {
                var selectedFieldNamesSet = selectedFieldNames.ToHashSet(StringComparer.OrdinalIgnoreCase);

                foreach (var columnElement in columnContextsElement.EnumerateArray())
                {
                    var columnName = columnElement.GetProperty("columnName").GetString();

                    // Only include contexts for selected fields
                    if (!string.IsNullOrEmpty(columnName) && selectedFieldNamesSet.Contains(columnName))
                    {
                        var columnContext = new AutoGeneratedColumnContext
                        {
                            ColumnName = columnName,
                            BusinessName = columnElement.GetProperty("businessName").GetString() ?? columnName,
                            BusinessDescription = columnElement.GetProperty("businessDescription").GetString() ?? "Business description not available",
                            DataType = "varchar", // Default data type
                            BusinessDataType = columnElement.GetProperty("businessDataType").GetString() ?? "Text",
                            ConfidenceScore = columnElement.GetProperty("confidenceScore").GetDouble(),
                            IsAutoGenerated = true,
                            IsPrimaryKey = false,
                            IsForeignKey = false,
                            SampleValues = new List<string>(),
                            BusinessRules = new List<string>(),
                            CommonUseCases = new List<string>()
                        };

                        tableContext.Columns.Add(columnContext);
                    }
                }
            }

            _logger.LogDebug("‚úÖ Parsed table context for {TableName} with {ColumnCount} column contexts",
                tableMetadata.Name, tableContext.Columns.Count);

            return tableContext;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Error parsing table context response for {TableName}", tableMetadata.Name);
            throw;
        }
    }













    /// <summary>
    /// Generate table contexts with progress reporting
    /// </summary>
    private async Task<List<AutoGeneratedTableContext>> GenerateTableContextsWithProgressAsync(string userId)
    {
        var progressCallback = CreateProgressCallback(userId, "Table Processing");
        return await GenerateTableContextsAsync(progressCallback);
    }

    /// <summary>
    /// Generate glossary terms with progress reporting
    /// </summary>
    private async Task<List<AutoGeneratedGlossaryTerm>> GenerateGlossaryTermsWithProgressAsync(List<string>? specificTables, string userId)
    {
        var progressCallback = CreateProgressCallback(userId, "Glossary Generation");
        return await GenerateGlossaryTermsAsync(specificTables, progressCallback, false);
    }

    /// <summary>
    /// Create a progress callback that reports to SignalR
    /// </summary>
    private Func<string, string, string?, Task> CreateProgressCallback(string userId, string baseStage)
    {
        return async (stage, message, currentItem) =>
        {
            if (_progressHub != null)
            {
                // Calculate progress based on stage
                var progress = CalculateProgressFromStage(stage);
                _logger.LogInformation("üì° Sending progress update to user {UserId}: {Progress}% - {Message} ({Stage})",
                    userId, progress, message, stage);
                await _progressHub.SendProgressUpdateAsync(userId, "auto-generation", progress, message);
            }
        };
    }

    /// <summary>
    /// Calculate progress percentage based on stage
    /// </summary>
    private int CalculateProgressFromStage(string stage)
    {
        return stage switch
        {
            "Schema Loading" => 10,
            "Table Processing" => 30,
            "Column Analysis" => 40,
            "AI Processing" => 50,
            "Content Generation" => 70,
            "Glossary Generation" => 80,
            "Validation" => 90,
            "Completion" => 100,
            _ => 25
        };
    }

    #endregion

    // AI Service Helper methods are now handled by the AIServiceHelper component







    #endregion
}
