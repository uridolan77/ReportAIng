import React, { useState, useEffect } from 'react';
import {
  Modal,
  Tabs,
  Table,
  Button,
  Space,
  Typography,
  Tag,
  Input,
  Form,
  message,
  Popconfirm,
  Card,
  Descriptions,
  Divider,
  Alert
} from 'antd';
import {
  EditOutlined,
  SaveOutlined,
  DeleteOutlined,
  EyeOutlined,
  CheckOutlined,
  CloseOutlined,
  HistoryOutlined,
  LinkOutlined,
  SettingOutlined
} from '@ant-design/icons';
import { AutoGenerationResponse, AutoGeneratedTableContext, AutoGeneratedGlossaryTerm } from '../../services/tuningApi';
import { tuningApi } from '../../services/tuningApi';
import { GlossaryTermsManager } from './GlossaryTermsManager';
import { ContentVersionHistory } from './ContentVersionHistory';
import { ContentVersion } from '../../types/dbExplorer';
import { useNavigate } from 'react-router-dom';

const { Title, Text, Paragraph } = Typography;
const { TabPane } = Tabs;
const { TextArea } = Input;

interface ContentManagementModalProps {
  visible: boolean;
  onClose: () => void;
  generationResults: AutoGenerationResponse | null;
  onContentSaved?: (savedContent: any) => void;
}

interface EditableTableContext extends AutoGeneratedTableContext {
  isEditing?: boolean;
  isSaved?: boolean;
}

interface EditableGlossaryTerm extends AutoGeneratedGlossaryTerm {
  isEditing?: boolean;
  isSaved?: boolean;
}

export const ContentManagementModal: React.FC<ContentManagementModalProps> = ({
  visible,
  onClose,
  generationResults,
  onContentSaved
}) => {
  const [tableContexts, setTableContexts] = useState<EditableTableContext[]>([]);
  const [glossaryTerms, setGlossaryTerms] = useState<EditableGlossaryTerm[]>([]);
  const [saving, setSaving] = useState(false);
  const [glossaryManagerVisible, setGlossaryManagerVisible] = useState(false);
  const [versionHistoryVisible, setVersionHistoryVisible] = useState(false);
  const [selectedContentForHistory, setSelectedContentForHistory] = useState<{
    id: string;
    name: string;
    type: 'table_context' | 'glossary_term';
    versions: ContentVersion[];
  } | null>(null);
  const [form] = Form.useForm();
  const navigate = useNavigate();

  // Initialize data when modal opens
  useEffect(() => {
    if (visible && generationResults) {
      console.log('ðŸ“‹ ContentManagementModal: Initializing with generation results');

      setTableContexts((generationResults.GeneratedTableContexts || []).map(ctx => ({ ...ctx, isEditing: false, isSaved: false })));
      setGlossaryTerms((generationResults.GeneratedGlossaryTerms || []).map(term => ({ ...term, isEditing: false, isSaved: false })));
    }
  }, [visible, generationResults]);

  // Table context columns
  const tableContextColumns = [
    {
      title: 'Table Name',
      dataIndex: 'tableName',
      key: 'tableName',
      render: (text: string, record: EditableTableContext) => (
        <Space>
          <Text strong>{text}</Text>
          {record.isSaved && <Tag color="green">Saved</Tag>}
        </Space>
      )
    },
    {
      title: 'Business Purpose',
      dataIndex: 'businessPurpose',
      key: 'businessPurpose',
      ellipsis: true,
      render: (text: string, record: EditableTableContext, index: number) =>
        record.isEditing ? (
          <Input
            defaultValue={text}
            onBlur={(e) => handleUpdateTableContext(index, 'businessPurpose', e.target.value)}
            onPressEnter={(e) => handleUpdateTableContext(index, 'businessPurpose', (e.target as HTMLInputElement).value)}
            autoFocus
          />
        ) : (
          <Text>{text}</Text>
        )
    },
    {
      title: 'Confidence',
      dataIndex: 'confidenceScore',
      key: 'confidenceScore',
      width: 100,
      render: (score: number) => (
        <Tag color={score > 0.8 ? 'green' : score > 0.6 ? 'orange' : 'red'}>
          {Math.round(score * 100)}%
        </Tag>
      )
    },
    {
      title: 'Actions',
      key: 'actions',
      width: 150,
      render: (_: any, record: EditableTableContext, index: number) => (
        <Space>
          <Button
            type="text"
            icon={<EyeOutlined />}
            size="small"
            onClick={() => handleViewTableContext(record)}
          />
          <Button
            type="text"
            icon={<EditOutlined />}
            size="small"
            onClick={() => handleEditTableContext(index)}
            title="Edit inline"
          />
          <Button
            type="text"
            icon={<EditOutlined />}
            size="small"
            onClick={() => handleEditTableContextDetailed(record)}
            title="Edit detailed"
          />
          <Button
            type="text"
            icon={<HistoryOutlined />}
            size="small"
            onClick={() => handleViewHistory(record.tableName, 'table_context')}
            title="View history"
          />
          <Button
            type="primary"
            icon={<SaveOutlined />}
            size="small"
            loading={saving}
            disabled={record.isSaved}
            onClick={() => handleSaveTableContext(record, index)}
          >
            {record.isSaved ? 'Saved' : 'Save'}
          </Button>
        </Space>
      )
    }
  ];

  // Glossary terms columns
  const glossaryColumns = [
    {
      title: 'Term',
      dataIndex: 'term',
      key: 'term',
      render: (text: string, record: EditableGlossaryTerm) => (
        <Space>
          <Text strong>{text}</Text>
          {record.isSaved && <Tag color="green">Saved</Tag>}
        </Space>
      )
    },
    {
      title: 'Definition',
      dataIndex: 'definition',
      key: 'definition',
      ellipsis: true,
      render: (text: string, record: EditableGlossaryTerm, index: number) =>
        record.isEditing ? (
          <TextArea
            defaultValue={text}
            onBlur={(e) => handleUpdateGlossaryTerm(index, 'definition', e.target.value)}
            autoSize={{ minRows: 2, maxRows: 4 }}
            autoFocus
          />
        ) : (
          <Text>{text}</Text>
        )
    },
    {
      title: 'Category',
      dataIndex: 'category',
      key: 'category',
      render: (text: string) => <Tag>{text || 'General'}</Tag>
    },
    {
      title: 'Actions',
      key: 'actions',
      width: 150,
      render: (_: any, record: EditableGlossaryTerm, index: number) => (
        <Space>
          <Button
            type="text"
            icon={<EditOutlined />}
            size="small"
            onClick={() => handleEditGlossaryTerm(index)}
          />
          <Button
            type="primary"
            icon={<SaveOutlined />}
            size="small"
            loading={saving}
            disabled={record.isSaved}
            onClick={() => handleSaveGlossaryTerm(record, index)}
          >
            {record.isSaved ? 'Saved' : 'Save'}
          </Button>
        </Space>
      )
    }
  ];

  const handleViewTableContext = (context: EditableTableContext) => {
    Modal.info({
      title: `Table Context: ${context.tableName}`,
      width: 800,
      content: (
        <div style={{ marginTop: 16 }}>
          <Descriptions column={1} bordered size="small">
            <Descriptions.Item label="Schema">{context.schemaName}</Descriptions.Item>
            <Descriptions.Item label="Business Purpose">{context.businessPurpose}</Descriptions.Item>
            <Descriptions.Item label="Business Context">{context.businessContext}</Descriptions.Item>
            <Descriptions.Item label="Primary Use Case">{context.primaryUseCase}</Descriptions.Item>
            <Descriptions.Item label="Confidence Score">
              <Tag color={context.confidenceScore > 0.8 ? 'green' : context.confidenceScore > 0.6 ? 'orange' : 'red'}>
                {Math.round(context.confidenceScore * 100)}%
              </Tag>
            </Descriptions.Item>
          </Descriptions>
          
          {context.commonQueryPatterns && context.commonQueryPatterns.length > 0 && (
            <>
              <Divider>Common Query Patterns</Divider>
              <ul>
                {context.commonQueryPatterns.map((pattern, idx) => (
                  <li key={idx}>{pattern}</li>
                ))}
              </ul>
            </>
          )}
          
          {context.columns && context.columns.length > 0 && (
            <>
              <Divider>Column Contexts</Divider>
              {context.columns.map((col, idx) => (
                <Card key={idx} size="small" style={{ marginBottom: 8 }}>
                  <Text strong>{col.columnName}</Text>: {col.businessMeaning}
                </Card>
              ))}
            </>
          )}
        </div>
      )
    });
  };

  const handleEditTableContext = (index: number) => {
    const newContexts = [...tableContexts];
    newContexts[index].isEditing = true;
    setTableContexts(newContexts);
  };

  const handleEditGlossaryTerm = (index: number) => {
    const newTerms = [...glossaryTerms];
    newTerms[index].isEditing = true;
    setGlossaryTerms(newTerms);
  };

  const handleUpdateTableContext = (index: number, field: keyof EditableTableContext, value: string) => {
    const newContexts = [...tableContexts];
    (newContexts[index] as any)[field] = value;
    newContexts[index].isEditing = false;
    setTableContexts(newContexts);
  };

  const handleUpdateGlossaryTerm = (index: number, field: keyof EditableGlossaryTerm, value: string) => {
    const newTerms = [...glossaryTerms];
    (newTerms[index] as any)[field] = value;
    newTerms[index].isEditing = false;
    setGlossaryTerms(newTerms);
  };

  const handleEditTableContextDetailed = (context: EditableTableContext) => {
    const index = tableContexts.findIndex(ctx => ctx.tableName === context.tableName);

    Modal.confirm({
      title: `Edit Table Context: ${context.tableName}`,
      width: 800,
      content: (
        <Form
          layout="vertical"
          initialValues={{
            businessPurpose: context.businessPurpose,
            businessContext: context.businessContext,
            primaryUseCase: context.primaryUseCase,
            businessRules: context.businessRules
          }}
          onFinish={(values) => {
            const newContexts = [...tableContexts];
            newContexts[index] = {
              ...newContexts[index],
              businessPurpose: values.businessPurpose,
              businessContext: values.businessContext,
              primaryUseCase: values.primaryUseCase,
              businessRules: values.businessRules
            };
            setTableContexts(newContexts);
            message.success('Table context updated');
          }}
        >
          <Form.Item name="businessPurpose" label="Business Purpose">
            <Input />
          </Form.Item>
          <Form.Item name="businessContext" label="Business Context">
            <TextArea rows={3} />
          </Form.Item>
          <Form.Item name="primaryUseCase" label="Primary Use Case">
            <Input />
          </Form.Item>
          <Form.Item name="businessRules" label="Business Rules">
            <TextArea rows={2} />
          </Form.Item>
        </Form>
      ),
      onOk: () => {
        // Form submission is handled in onFinish
        return Promise.resolve();
      }
    });
  };

  const handleViewHistory = (itemName: string, type: 'table_context' | 'glossary_term') => {
    // Mock version history for demonstration
    const mockVersions: ContentVersion[] = [
      {
        id: '1',
        timestamp: new Date().toISOString(),
        author: 'Current User',
        changes: [
          {
            type,
            action: 'updated',
            itemId: itemName,
            itemName,
            fieldChanges: [
              {
                field: 'businessPurpose',
                oldValue: 'Previous business purpose',
                newValue: 'Updated business purpose'
              }
            ]
          }
        ],
        comment: 'Updated business context based on stakeholder feedback'
      },
      {
        id: '2',
        timestamp: new Date(Date.now() - 86400000).toISOString(),
        author: 'System',
        changes: [
          {
            type,
            action: 'created',
            itemId: itemName,
            itemName
          }
        ],
        comment: 'Auto-generated from database schema analysis'
      }
    ];

    setSelectedContentForHistory({
      id: itemName,
      name: itemName,
      type,
      versions: mockVersions
    });
    setVersionHistoryVisible(true);
  };

  const handleSaveTableContext = async (context: EditableTableContext, index: number) => {
    try {
      setSaving(true);
      const saved = await tuningApi.saveGeneratedTableContext(context);
      
      const newContexts = [...tableContexts];
      newContexts[index].isSaved = true;
      newContexts[index].isEditing = false;
      setTableContexts(newContexts);
      
      message.success(`Table context for ${context.tableName} saved successfully`);
      onContentSaved?.(saved);
    } catch (error) {
      message.error(`Failed to save table context: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setSaving(false);
    }
  };

  const handleSaveGlossaryTerm = async (term: EditableGlossaryTerm, index: number) => {
    try {
      setSaving(true);
      const saved = await tuningApi.saveGeneratedGlossaryTerm(term);
      
      const newTerms = [...glossaryTerms];
      newTerms[index].isSaved = true;
      newTerms[index].isEditing = false;
      setGlossaryTerms(newTerms);
      
      message.success(`Glossary term "${term.term}" saved successfully`);
      onContentSaved?.(saved);
    } catch (error) {
      message.error(`Failed to save glossary term: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setSaving(false);
    }
  };

  const handleSaveAll = async () => {
    if (!generationResults) return;
    
    try {
      setSaving(true);
      const result = await tuningApi.saveGeneratedContent(generationResults);
      
      // Update saved status
      setTableContexts(prev => prev.map(ctx => ({ ...ctx, isSaved: true })));
      setGlossaryTerms(prev => prev.map(term => ({ ...term, isSaved: true })));
      
      if (result.errors.length > 0) {
        message.warning(`Saved with ${result.errors.length} errors. Check console for details.`);
        console.error('Save errors:', result.errors);
      } else {
        message.success(`Successfully saved ${result.savedTableContexts.length} table contexts and ${result.savedGlossaryTerms.length} glossary terms`);
      }
      
      onContentSaved?.(result);
    } catch (error) {
      message.error(`Failed to save content: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setSaving(false);
    }
  };

  const handleNavigateToTuning = () => {
    navigate('/tuning');
    onClose();
  };

  const handleNavigateToBusinessContext = () => {
    navigate('/tuning/business-context');
    onClose();
  };

  const handleNavigateToGlossary = () => {
    navigate('/tuning/glossary');
    onClose();
  };

  if (!generationResults) {
    return null;
  }

  return (
    <Modal
      title="Manage Generated Content"
      open={visible}
      onCancel={onClose}
      width={1200}
      footer={[
        <Button key="close" onClick={onClose}>
          Close
        </Button>,
        <Button
          key="tuning"
          icon={<SettingOutlined />}
          onClick={handleNavigateToTuning}
        >
          Open Tuning Interface
        </Button>,
        <Button
          key="business-context"
          icon={<LinkOutlined />}
          onClick={handleNavigateToBusinessContext}
        >
          Manage Business Context
        </Button>,
        <Button
          key="save-all"
          type="primary"
          loading={saving}
          onClick={handleSaveAll}
          icon={<SaveOutlined />}
        >
          Save All to Database
        </Button>
      ]}
    >
      <Space direction="vertical" style={{ width: '100%' }} size="middle">
        <Alert
          message="Review and Save Generated Content"
          description="Review the auto-generated business contexts and glossary terms below. You can edit individual items or save all content to the database."
          type="info"
          showIcon
        />

        <Alert
          message="Integration with Tuning Interface"
          description={
            <Space direction="vertical" style={{ width: '100%' }}>
              <Text>Once saved, your content will be available in the main tuning interface:</Text>
              <ul style={{ margin: 0, paddingLeft: 20 }}>
                <li>Table contexts will appear in Business Context Management</li>
                <li>Glossary terms will be added to the Business Glossary</li>
                <li>All content can be further refined using the advanced tuning tools</li>
              </ul>
            </Space>
          }
          type="success"
          showIcon
        />
      </Space>

      <Tabs defaultActiveKey="tables">
        <TabPane tab={`Table Contexts (${tableContexts.length})`} key="tables">
          <Table
            dataSource={tableContexts}
            columns={tableContextColumns}
            rowKey="tableName"
            size="small"
            pagination={{ pageSize: 10 }}
          />
        </TabPane>
        
        <TabPane tab={`Glossary Terms (${glossaryTerms.length})`} key="glossary">
          <Space direction="vertical" style={{ width: '100%' }} size="middle">
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <Text>Manage glossary terms generated from the auto-generation process</Text>
              <Button
                type="primary"
                icon={<EditOutlined />}
                onClick={() => setGlossaryManagerVisible(true)}
              >
                Advanced Glossary Manager
              </Button>
            </div>
            <Table
              dataSource={glossaryTerms}
              columns={glossaryColumns}
              rowKey="term"
              size="small"
              pagination={{ pageSize: 10 }}
            />
          </Space>
        </TabPane>
      </Tabs>

      {/* Advanced Glossary Manager */}
      <GlossaryTermsManager
        visible={glossaryManagerVisible}
        onClose={() => setGlossaryManagerVisible(false)}
        initialTerms={glossaryTerms}
        onTermsUpdated={(updatedTerms) => {
          setGlossaryTerms(updatedTerms.map(term => ({ ...term, isEditing: false, isSaved: true })));
          message.success('Glossary terms updated successfully');
        }}
      />

      {/* Version History Modal */}
      {selectedContentForHistory && (
        <ContentVersionHistory
          visible={versionHistoryVisible}
          onClose={() => {
            setVersionHistoryVisible(false);
            setSelectedContentForHistory(null);
          }}
          contentId={selectedContentForHistory.id}
          contentName={selectedContentForHistory.name}
          contentType={selectedContentForHistory.type}
          versions={selectedContentForHistory.versions}
          onRevertToVersion={(versionId) => {
            message.info(`Reverting to version ${versionId} - This feature would restore the content to the selected version`);
            setVersionHistoryVisible(false);
          }}
        />
      )}
    </Modal>
  );
};
