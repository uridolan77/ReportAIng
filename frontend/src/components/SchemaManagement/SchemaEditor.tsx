import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '../ui';
import { Button } from '../ui';
import { Input } from '../ui';
import { Textarea } from '../ui';
import { Badge } from '../ui';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '../ui';
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from '../ui';
import { 
  Save, 
  Plus, 
  Edit, 
  Trash2, 
  Database, 
  Columns, 
  BookOpen, 
  Link,
  Search,
  Filter
} from 'lucide-react';
import { BusinessSchemaDto, BusinessSchemaVersionDto } from '../../types/schemaManagement';
import { TableContextEditor } from './TableContextEditor';
import { ColumnContextEditor } from './ColumnContextEditor';
import { GlossaryTermEditor } from './GlossaryTermEditor';
import { RelationshipEditor } from './RelationshipEditor';
import { schemaManagementApi } from '../../services/schemaManagementApi';

interface SchemaEditorProps {
  schema: BusinessSchemaDto;
  version: BusinessSchemaVersionDto | null;
  onSchemaUpdated: (schema: BusinessSchemaDto) => void;
}

export const SchemaEditor: React.FC<SchemaEditorProps> = ({
  schema,
  version,
  onSchemaUpdated
}) => {
  const [activeTab, setActiveTab] = useState('tables');
  const [searchTerm, setSearchTerm] = useState('');
  const [filterType, setFilterType] = useState<'all' | 'auto' | 'manual'>('all');
  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);

  // Schema basic info editing
  const [editingSchema, setEditingSchema] = useState(false);
  const [schemaForm, setSchemaForm] = useState({
    name: schema.name,
    description: schema.description || '',
    tags: schema.tags.join(', ')
  });

  // Version data
  const [tableContexts, setTableContexts] = useState<any[]>([]);
  const [columnContexts, setColumnContexts] = useState<any[]>([]);
  const [glossaryTerms, setGlossaryTerms] = useState<any[]>([]);
  const [relationships, setRelationships] = useState<any[]>([]);

  useEffect(() => {
    if (version) {
      loadVersionData();
    }
  }, [version]);

  const loadVersionData = async () => {
    if (!version) return;

    try {
      setLoading(true);
      const versionDetails = await schemaManagementApi.getSchemaVersion(version.id);
      setTableContexts(versionDetails.tableContexts || []);
      setColumnContexts(versionDetails.columnContexts || []);
      setGlossaryTerms(versionDetails.glossaryTerms || []);
      setRelationships(versionDetails.relationships || []);
    } catch (error) {
      console.error('Error loading version data:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleSaveSchema = async () => {
    try {
      setSaving(true);
      const updatedSchema = await schemaManagementApi.updateSchema(schema.id, {
        name: schemaForm.name,
        description: schemaForm.description,
        tags: schemaForm.tags.split(',').map(t => t.trim()).filter(t => t)
      });
      onSchemaUpdated(updatedSchema);
      setEditingSchema(false);
    } catch (error) {
      console.error('Error updating schema:', error);
    } finally {
      setSaving(false);
    }
  };

  const filteredTableContexts = tableContexts.filter(table => {
    const matchesSearch = !searchTerm || 
      table.tableName.toLowerCase().includes(searchTerm.toLowerCase()) ||
      table.businessPurpose?.toLowerCase().includes(searchTerm.toLowerCase());
    
    const matchesFilter = filterType === 'all' || 
      (filterType === 'auto' && table.isAutoGenerated) ||
      (filterType === 'manual' && !table.isAutoGenerated);

    return matchesSearch && matchesFilter;
  });

  const filteredGlossaryTerms = glossaryTerms.filter(term => {
    const matchesSearch = !searchTerm || 
      term.term.toLowerCase().includes(searchTerm.toLowerCase()) ||
      term.definition.toLowerCase().includes(searchTerm.toLowerCase());
    
    const matchesFilter = filterType === 'all' || 
      (filterType === 'auto' && term.isAutoGenerated) ||
      (filterType === 'manual' && !term.isAutoGenerated);

    return matchesSearch && matchesFilter;
  });

  if (!version) {
    return (
      <Card>
        <CardContent className="p-8 text-center">
          <Database className="h-12 w-12 text-gray-400 mx-auto mb-4" />
          <h3 className="text-lg font-medium text-gray-900 mb-2">
            No Version Selected
          </h3>
          <p className="text-gray-600">
            Select a schema version to edit its business context.
          </p>
        </CardContent>
      </Card>
    );
  }

  if (loading) {
    return (
      <Card>
        <CardContent className="p-8 text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4"></div>
          <p className="text-gray-600">Loading schema data...</p>
        </CardContent>
      </Card>
    );
  }

  return (
    <div className="space-y-6">
      {/* Schema Info Editor */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center justify-between">
            <span>Schema Information</span>
            <Button
              variant={editingSchema ? "default" : "outline"}
              size="sm"
              onClick={() => editingSchema ? handleSaveSchema() : setEditingSchema(true)}
              disabled={saving}
            >
              {editingSchema ? (
                <>
                  <Save className="h-4 w-4 mr-2" />
                  {saving ? 'Saving...' : 'Save'}
                </>
              ) : (
                <>
                  <Edit className="h-4 w-4 mr-2" />
                  Edit
                </>
              )}
            </Button>
          </CardTitle>
        </CardHeader>
        <CardContent>
          {editingSchema ? (
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Schema Name
                </label>
                <Input
                  value={schemaForm.name}
                  onChange={(e) => setSchemaForm(prev => ({ ...prev, name: e.target.value }))}
                  placeholder="Enter schema name"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Description
                </label>
                <Textarea
                  value={schemaForm.description}
                  onChange={(e) => setSchemaForm(prev => ({ ...prev, description: e.target.value }))}
                  placeholder="Enter schema description"
                  rows={3}
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Tags (comma-separated)
                </label>
                <Input
                  value={schemaForm.tags}
                  onChange={(e) => setSchemaForm(prev => ({ ...prev, tags: e.target.value }))}
                  placeholder="e.g., Finance, Analytics, Production"
                />
              </div>
              <div className="flex gap-2">
                <Button onClick={handleSaveSchema} disabled={saving}>
                  <Save className="h-4 w-4 mr-2" />
                  {saving ? 'Saving...' : 'Save Changes'}
                </Button>
                <Button 
                  variant="outline" 
                  onClick={() => {
                    setEditingSchema(false);
                    setSchemaForm({
                      name: schema.name,
                      description: schema.description || '',
                      tags: schema.tags.join(', ')
                    });
                  }}
                >
                  Cancel
                </Button>
              </div>
            </div>
          ) : (
            <div className="space-y-4">
              <div>
                <h4 className="font-medium text-gray-900">{schema.name}</h4>
                <p className="text-gray-600 mt-1">
                  {schema.description || 'No description provided'}
                </p>
              </div>
              <div>
                <h4 className="font-medium text-gray-900 mb-2">Tags</h4>
                <div className="flex flex-wrap gap-1">
                  {schema.tags.map((tag, index) => (
                    <Badge key={index} variant="outline">{tag}</Badge>
                  ))}
                </div>
              </div>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Version Content Editor */}
      <Card>
        <CardHeader>
          <CardTitle>
            Business Context - {version.versionName || `Version ${version.versionNumber}`}
          </CardTitle>
          <div className="flex items-center gap-4">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-gray-400" />
              <Input
                placeholder="Search..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="w-64"
              />
            </div>
            <div className="flex items-center gap-2">
              <Filter className="h-4 w-4 text-gray-400" />
              <select
                value={filterType}
                onChange={(e) => setFilterType(e.target.value as any)}
                className="border border-gray-300 rounded-md px-3 py-1 text-sm"
              >
                <option value="all">All Items</option>
                <option value="auto">Auto-generated</option>
                <option value="manual">Manual</option>
              </select>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          <Tabs value={activeTab} onValueChange={setActiveTab}>
            <TabsList className="grid w-full grid-cols-4">
              <TabsTrigger value="tables" className="flex items-center gap-2">
                <Database className="h-4 w-4" />
                Tables ({filteredTableContexts.length})
              </TabsTrigger>
              <TabsTrigger value="columns" className="flex items-center gap-2">
                <Columns className="h-4 w-4" />
                Columns ({columnContexts.length})
              </TabsTrigger>
              <TabsTrigger value="glossary" className="flex items-center gap-2">
                <BookOpen className="h-4 w-4" />
                Glossary ({filteredGlossaryTerms.length})
              </TabsTrigger>
              <TabsTrigger value="relationships" className="flex items-center gap-2">
                <Link className="h-4 w-4" />
                Relations ({relationships.length})
              </TabsTrigger>
            </TabsList>

            <TabsContent value="tables" className="mt-6">
              <div className="space-y-4">
                {filteredTableContexts.length === 0 ? (
                  <div className="text-center py-8">
                    <Database className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                    <h3 className="text-lg font-medium text-gray-900 mb-2">No Tables Found</h3>
                    <p className="text-gray-600">
                      {searchTerm ? 'No tables match your search criteria.' : 'No table contexts available.'}
                    </p>
                  </div>
                ) : (
                  <Accordion type="single" collapsible className="w-full">
                    {filteredTableContexts.map((table, index) => (
                      <AccordionItem key={table.id} value={`table-${index}`}>
                        <AccordionTrigger className="hover:no-underline">
                          <div className="flex items-center justify-between w-full mr-4">
                            <div className="flex items-center gap-3">
                              <span className="font-medium">{table.tableName}</span>
                              {table.isAutoGenerated && (
                                <Badge variant="secondary" className="text-xs">Auto</Badge>
                              )}
                            </div>
                            <span className="text-sm text-gray-500 truncate max-w-md">
                              {table.businessPurpose || 'No purpose defined'}
                            </span>
                          </div>
                        </AccordionTrigger>
                        <AccordionContent>
                          <TableContextEditor
                            tableContext={table}
                            onUpdate={(updated) => {
                              setTableContexts(prev => 
                                prev.map(t => t.id === updated.id ? updated : t)
                              );
                            }}
                          />
                        </AccordionContent>
                      </AccordionItem>
                    ))}
                  </Accordion>
                )}
              </div>
            </TabsContent>

            <TabsContent value="columns" className="mt-6">
              <ColumnContextEditor
                columnContexts={columnContexts}
                tableContexts={tableContexts}
                searchTerm={searchTerm}
                filterType={filterType}
                onUpdate={(updated) => {
                  setColumnContexts(prev => 
                    prev.map(c => c.id === updated.id ? updated : c)
                  );
                }}
              />
            </TabsContent>

            <TabsContent value="glossary" className="mt-6">
              <GlossaryTermEditor
                glossaryTerms={filteredGlossaryTerms}
                onUpdate={(updated) => {
                  setGlossaryTerms(prev => 
                    prev.map(g => g.id === updated.id ? updated : g)
                  );
                }}
                onAdd={(newTerm) => {
                  setGlossaryTerms(prev => [...prev, newTerm]);
                }}
              />
            </TabsContent>

            <TabsContent value="relationships" className="mt-6">
              <RelationshipEditor
                relationships={relationships}
                tableContexts={tableContexts}
                onUpdate={(updated) => {
                  setRelationships(prev => 
                    prev.map(r => r.id === updated.id ? updated : r)
                  );
                }}
                onAdd={(newRelationship) => {
                  setRelationships(prev => [...prev, newRelationship]);
                }}
              />
            </TabsContent>
          </Tabs>
        </CardContent>
      </Card>
    </div>
  );
};
