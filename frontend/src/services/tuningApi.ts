import { API_CONFIG, getAuthHeaders } from '../config/api';

// Types
export interface BusinessTableInfo {
  id: number;
  tableName: string;
  schemaName: string;
  businessPurpose: string;
  businessContext: string;
  primaryUseCase: string;
  commonQueryPatterns: string[];
  businessRules: string;
  isActive: boolean;
  columns: BusinessColumnInfo[];
}

export interface BusinessColumnInfo {
  id: number;
  columnName: string;
  businessMeaning: string;
  businessContext: string;
  dataExamples: string[];
  validationRules: string;
  isKeyColumn: boolean;
  isActive: boolean;
}

export interface QueryPattern {
  id: number;
  patternName: string;
  naturalLanguagePattern: string;
  sqlTemplate: string;
  description: string;
  businessContext: string;
  keywords: string[];
  requiredTables: string[];
  priority: number;
  isActive: boolean;
}

export interface BusinessGlossaryTerm {
  id: number;
  term: string;
  definition: string;
  businessContext: string;
  synonyms: string[];
  relatedTerms: string[];
  category: string;
  isActive: boolean;
}

export interface AITuningSetting {
  id: number;
  settingKey: string;
  settingValue: string;
  description: string;
  category: string;
  dataType: string;
  isActive: boolean;
}

export interface PromptLog {
  id: number;
  promptType: string;
  userQuery: string;
  fullPrompt: string;
  generatedSQL?: string;
  success?: boolean;
  errorMessage?: string;
  promptLength: number;
  responseLength?: number;
  executionTimeMs?: number;
  createdDate: string;
  userId?: string;
  sessionId?: string;
  metadata?: string;
}

export interface TuningDashboardData {
  totalTables: number;
  totalColumns: number;
  totalPatterns: number;
  totalGlossaryTerms: number;
  activePromptTemplates: number;
  recentlyUpdatedTables: string[];
  mostUsedPatterns: string[];
  patternUsageStats: Record<string, number>;
}

export interface CreateTableRequest {
  tableName: string;
  schemaName: string;
  businessPurpose: string;
  businessContext: string;
  primaryUseCase: string;
  commonQueryPatterns: string[];
  businessRules: string;
  columns: CreateColumnRequest[];
}

export interface CreateColumnRequest {
  columnName: string;
  businessMeaning: string;
  businessContext: string;
  dataExamples: string[];
  validationRules: string;
  isKeyColumn: boolean;
}

export interface CreateQueryPatternRequest {
  patternName: string;
  naturalLanguagePattern: string;
  sqlTemplate: string;
  description: string;
  businessContext: string;
  keywords: string[];
  requiredTables: string[];
  priority: number;
}

// Auto-Generation Types
export interface AutoGeneratedTableContext {
  tableName: string;
  schemaName: string;
  businessPurpose: string;
  businessContext: string;
  primaryUseCase: string;
  keyBusinessMetrics: string[];
  commonQueryPatterns: string[];
  businessRules: string;
  columns: AutoGeneratedColumnContext[];
  relatedTables: string[];
  confidenceScore: number;
  generatedAt: string;
  generationMethod: string;
  isAutoGenerated: boolean;
}

export interface AutoGeneratedColumnContext {
  columnName: string;
  businessName: string;
  businessDescription: string;
  dataType: string;
  businessDataType: string;
  sampleValues: string[];
  valueRange: string;
  businessRules: string[];
  commonUseCases: string[];
  isPrimaryKey: boolean;
  isForeignKey: boolean;
  referencedTable?: string;
  confidenceScore: number;
  isAutoGenerated: boolean;
}

export interface AutoGeneratedGlossaryTerm {
  term: string;
  definition: string;
  businessContext: string;
  synonyms: string[];
  relatedTerms: string[];
  category: string;
  sourceTables: string[];
  sourceColumns: string[];
  dataType: string;
  exampleValues: string[];
  confidenceScore: number;
  generatedAt: string;
  isAutoGenerated: boolean;
}

export interface BusinessRelationshipAnalysis {
  relationships: TableRelationship[];
  businessDomains: BusinessDomain[];
  dataFlows: DataFlow[];
  analyzedAt: string;
  overallConfidence: number;
}

export interface TableRelationship {
  fromTable: string;
  fromSchema: string;
  toTable: string;
  toSchema: string;
  relationshipType: string;
  businessRelationship: string;
  columnMappings: ColumnMapping[];
  confidenceScore: number;
}

export interface ColumnMapping {
  fromColumn: string;
  toColumn: string;
  businessMeaning: string;
}

export interface BusinessDomain {
  domainName: string;
  description: string;
  tables: string[];
  keyConcepts: string[];
  confidenceScore: number;
}

export interface DataFlow {
  flowName: string;
  businessProcess: string;
  tableSequence: string[];
  description: string;
  confidenceScore: number;
}

export interface AutoGenerationRequest {
  generateTableContexts: boolean;
  generateGlossaryTerms: boolean;
  analyzeRelationships: boolean;
  specificTables?: string[];
  specificSchemas?: string[];
  overwriteExisting: boolean;
  minimumConfidenceThreshold: number;
  mockMode?: boolean;
}

export interface AutoGenerationResponse {
  generatedTableContexts: AutoGeneratedTableContext[];
  generatedGlossaryTerms: AutoGeneratedGlossaryTerm[];
  relationshipAnalysis?: BusinessRelationshipAnalysis;
  totalTablesProcessed: number;
  totalColumnsProcessed: number;
  totalTermsGenerated: number;
  processingTime: string;
  warnings: string[];
  errors: string[];
  success: boolean;
}

export interface AutoGenerationProgress {
  currentTask: string;
  completedItems: number;
  totalItems: number;
  progressPercentage: number;
  currentTable?: string;
  recentlyCompleted: string[];
  elapsedTime: string;
  estimatedTimeRemaining?: string;
}

class TuningApiService {
  private baseUrl = API_CONFIG.BASE_URL;

  // Dashboard
  async getDashboard(): Promise<TuningDashboardData> {
    const response = await fetch(`${this.baseUrl}/api/tuning/dashboard`, {
      headers: await getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to get dashboard: ${response.statusText}`);
    }

    return response.json();
  }

  // Business Tables
  async getBusinessTables(): Promise<BusinessTableInfo[]> {
    const response = await fetch(`${this.baseUrl}/api/tuning/tables`, {
      headers: await getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to get business tables: ${response.statusText}`);
    }

    return response.json();
  }

  async getBusinessTable(id: number): Promise<BusinessTableInfo> {
    const response = await fetch(`${this.baseUrl}/api/tuning/tables/${id}`, {
      headers: await getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to get business table: ${response.statusText}`);
    }

    return response.json();
  }

  async createBusinessTable(request: CreateTableRequest): Promise<BusinessTableInfo> {
    const response = await fetch(`${this.baseUrl}/api/tuning/tables`, {
      method: 'POST',
      headers: {
        ...(await getAuthHeaders()),
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      throw new Error(`Failed to create business table: ${response.statusText}`);
    }

    return response.json();
  }

  async updateBusinessTable(id: number, request: CreateTableRequest): Promise<BusinessTableInfo> {
    const response = await fetch(`${this.baseUrl}/api/tuning/tables/${id}`, {
      method: 'PUT',
      headers: {
        ...(await getAuthHeaders()),
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      throw new Error(`Failed to update business table: ${response.statusText}`);
    }

    return response.json();
  }

  async deleteBusinessTable(id: number): Promise<void> {
    const response = await fetch(`${this.baseUrl}/api/tuning/tables/${id}`, {
      method: 'DELETE',
      headers: await getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to delete business table: ${response.statusText}`);
    }
  }

  // Query Patterns
  async getQueryPatterns(): Promise<QueryPattern[]> {
    const response = await fetch(`${this.baseUrl}/api/tuning/patterns`, {
      headers: await getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to get query patterns: ${response.statusText}`);
    }

    return response.json();
  }

  async getQueryPattern(id: number): Promise<QueryPattern> {
    const response = await fetch(`${this.baseUrl}/api/tuning/patterns/${id}`, {
      headers: await getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to get query pattern: ${response.statusText}`);
    }

    return response.json();
  }

  async createQueryPattern(request: CreateQueryPatternRequest): Promise<QueryPattern> {
    const response = await fetch(`${this.baseUrl}/api/tuning/patterns`, {
      method: 'POST',
      headers: {
        ...(await getAuthHeaders()),
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      throw new Error(`Failed to create query pattern: ${response.statusText}`);
    }

    return response.json();
  }

  async updateQueryPattern(id: number, request: CreateQueryPatternRequest): Promise<QueryPattern> {
    const response = await fetch(`${this.baseUrl}/api/tuning/patterns/${id}`, {
      method: 'PUT',
      headers: {
        ...(await getAuthHeaders()),
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      throw new Error(`Failed to update query pattern: ${response.statusText}`);
    }

    return response.json();
  }

  async deleteQueryPattern(id: number): Promise<void> {
    const response = await fetch(`${this.baseUrl}/api/tuning/patterns/${id}`, {
      method: 'DELETE',
      headers: await getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to delete query pattern: ${response.statusText}`);
    }
  }

  async testQueryPattern(id: number, naturalLanguageQuery: string): Promise<string> {
    const response = await fetch(`${this.baseUrl}/api/tuning/patterns/${id}/test`, {
      method: 'POST',
      headers: {
        ...(await getAuthHeaders()),
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(naturalLanguageQuery),
    });

    if (!response.ok) {
      throw new Error(`Failed to test query pattern: ${response.statusText}`);
    }

    return response.text();
  }

  // Business Glossary
  async getGlossaryTerms(): Promise<BusinessGlossaryTerm[]> {
    const response = await fetch(`${this.baseUrl}/api/tuning/glossary`, {
      headers: await getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to get glossary terms: ${response.statusText}`);
    }

    return response.json();
  }

  async createGlossaryTerm(request: BusinessGlossaryTerm): Promise<BusinessGlossaryTerm> {
    const response = await fetch(`${this.baseUrl}/api/tuning/glossary`, {
      method: 'POST',
      headers: {
        ...(await getAuthHeaders()),
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      throw new Error(`Failed to create glossary term: ${response.statusText}`);
    }

    return response.json();
  }

  async updateGlossaryTerm(id: number, request: BusinessGlossaryTerm): Promise<BusinessGlossaryTerm> {
    const response = await fetch(`${this.baseUrl}/api/tuning/glossary/${id}`, {
      method: 'PUT',
      headers: {
        ...(await getAuthHeaders()),
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      throw new Error(`Failed to update glossary term: ${response.statusText}`);
    }

    return response.json();
  }

  async deleteGlossaryTerm(id: number): Promise<void> {
    const response = await fetch(`${this.baseUrl}/api/tuning/glossary/${id}`, {
      method: 'DELETE',
      headers: await getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to delete glossary term: ${response.statusText}`);
    }
  }

  // AI Settings
  async getAISettings(): Promise<AITuningSetting[]> {
    const response = await fetch(`${this.baseUrl}/api/tuning/settings`, {
      headers: await getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to get AI settings: ${response.statusText}`);
    }

    return response.json();
  }

  async updateAISetting(id: number, request: AITuningSetting): Promise<AITuningSetting> {
    const response = await fetch(`${this.baseUrl}/api/tuning/settings/${id}`, {
      method: 'PUT',
      headers: {
        ...(await getAuthHeaders()),
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      throw new Error(`Failed to update AI setting: ${response.statusText}`);
    }

    return response.json();
  }

  // Prompt Logs
  async getPromptLogs(params: {
    page?: number;
    pageSize?: number;
    promptType?: string;
    success?: boolean;
    fromDate?: string;
    toDate?: string;
  }): Promise<PromptLog[]> {
    const searchParams = new URLSearchParams();

    if (params.page) searchParams.append('page', params.page.toString());
    if (params.pageSize) searchParams.append('pageSize', params.pageSize.toString());
    if (params.promptType) searchParams.append('promptType', params.promptType);
    if (params.success !== undefined) searchParams.append('success', params.success.toString());
    if (params.fromDate) searchParams.append('fromDate', params.fromDate);
    if (params.toDate) searchParams.append('toDate', params.toDate);

    const response = await fetch(`${this.baseUrl}/api/tuning/prompt-logs?${searchParams}`, {
      headers: await getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to get prompt logs: ${response.statusText}`);
    }

    return response.json();
  }

  async getPromptLog(id: number): Promise<PromptLog> {
    const response = await fetch(`${this.baseUrl}/api/tuning/prompt-logs/${id}`, {
      headers: await getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to get prompt log: ${response.statusText}`);
    }

    return response.json();
  }

  // Auto-Generation
  async autoGenerateBusinessContext(request: AutoGenerationRequest): Promise<AutoGenerationResponse> {
    const response = await fetch(`${this.baseUrl}/api/tuning/auto-generate`, {
      method: 'POST',
      headers: {
        ...(await getAuthHeaders()),
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      throw new Error(`Failed to auto-generate business context: ${response.statusText}`);
    }

    return response.json();
  }

  async autoGenerateTableContexts(): Promise<AutoGeneratedTableContext[]> {
    const response = await fetch(`${this.baseUrl}/api/tuning/auto-generate/tables`, {
      method: 'POST',
      headers: await getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to auto-generate table contexts: ${response.statusText}`);
    }

    return response.json();
  }

  async autoGenerateGlossaryTerms(): Promise<AutoGeneratedGlossaryTerm[]> {
    const response = await fetch(`${this.baseUrl}/api/tuning/auto-generate/glossary`, {
      method: 'POST',
      headers: await getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to auto-generate glossary terms: ${response.statusText}`);
    }

    return response.json();
  }

  async autoGenerateRelationshipAnalysis(): Promise<BusinessRelationshipAnalysis> {
    const response = await fetch(`${this.baseUrl}/api/tuning/auto-generate/relationships`, {
      method: 'POST',
      headers: await getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to auto-generate relationship analysis: ${response.statusText}`);
    }

    return response.json();
  }

  async autoGenerateTableContext(tableName: string, schemaName?: string): Promise<AutoGeneratedTableContext> {
    const params = new URLSearchParams();
    if (schemaName) params.append('schemaName', schemaName);

    const response = await fetch(`${this.baseUrl}/api/tuning/auto-generate/table/${tableName}?${params}`, {
      method: 'POST',
      headers: await getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to auto-generate table context: ${response.statusText}`);
    }

    return response.json();
  }

  async applyAutoGeneratedContext(autoGenerated: AutoGenerationResponse): Promise<void> {
    const response = await fetch(`${this.baseUrl}/api/tuning/auto-generate/apply`, {
      method: 'POST',
      headers: {
        ...(await getAuthHeaders()),
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(autoGenerated),
    });

    if (!response.ok) {
      throw new Error(`Failed to apply auto-generated context: ${response.statusText}`);
    }
  }

  // Additional methods for React Query hooks
  async getBusinessGlossary(): Promise<BusinessGlossaryTerm[]> {
    return this.getGlossaryTerms();
  }

  async updateBusinessGlossary(glossary: BusinessGlossaryTerm[]): Promise<void> {
    // Bulk update - this would need to be implemented on the backend
    for (const term of glossary) {
      if (term.id) {
        await this.updateGlossaryTerm(term.id, term);
      } else {
        await this.createGlossaryTerm(term);
      }
    }
  }

  // Removed duplicate function implementations to fix TypeScript errors

  // Removed duplicate wrapper functions - use autoGenerateTableContexts() and autoGenerateGlossaryTerms() directly

  async clearPromptCache(): Promise<void> {
    // This would need to be implemented on the backend
    const response = await fetch(`${this.baseUrl}/api/tuning/cache/clear`, {
      method: 'DELETE',
      headers: await getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to clear prompt cache: ${response.statusText}`);
    }
  }

  async testAISettings(settings: any): Promise<any> {
    const response = await fetch(`${this.baseUrl}/api/tuning/settings/test`, {
      method: 'POST',
      headers: {
        ...(await getAuthHeaders()),
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(settings),
    });

    if (!response.ok) {
      throw new Error(`Failed to test AI settings: ${response.statusText}`);
    }

    return response.json();
  }

  async bulkUpdateTables(tables: BusinessTableInfo[]): Promise<void> {
    const response = await fetch(`${this.baseUrl}/api/tuning/tables/bulk`, {
      method: 'PUT',
      headers: {
        ...(await getAuthHeaders()),
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(tables),
    });

    if (!response.ok) {
      throw new Error(`Failed to bulk update tables: ${response.statusText}`);
    }
  }

  async exportTuningData(format: 'json' | 'csv' | 'excel'): Promise<Blob> {
    const response = await fetch(`${this.baseUrl}/api/tuning/export?format=${format}`, {
      headers: await getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`Failed to export tuning data: ${response.statusText}`);
    }

    return response.blob();
  }

  async importTuningData(file: File): Promise<void> {
    const formData = new FormData();
    formData.append('file', file);

    const authHeaders = await getAuthHeaders();
    const headersWithoutContentType = { ...authHeaders };
    delete headersWithoutContentType['Content-Type']; // Remove Content-Type for FormData

    const response = await fetch(`${this.baseUrl}/api/tuning/import`, {
      method: 'POST',
      headers: headersWithoutContentType,
      body: formData,
    });

    if (!response.ok) {
      throw new Error(`Failed to import tuning data: ${response.statusText}`);
    }
  }
}

export const tuningApiService = new TuningApiService();
export const tuningApi = tuningApiService; // Backward compatibility
