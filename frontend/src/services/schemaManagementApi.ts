import apiClient from './api';
import {
  BusinessSchemaDto,
  BusinessSchemaVersionDto,
  SchemaTableContextDto,
  SchemaColumnContextDto,
  SchemaGlossaryTermDto,
  SchemaRelationshipDto,
  UserSchemaPreferenceDto,
  CreateSchemaRequest,
  UpdateSchemaRequest,
  CreateSchemaVersionRequest,
  UpdateTableContextRequest,
  UpdateColumnContextRequest,
  UpdateGlossaryTermRequest,
  UpdateRelationshipRequest,
  ApplyAutoGeneratedContentRequest,
  SchemaComparisonResult,
  SchemaExportData,
  SchemaImportRequest,
  ApiResponse
} from '@/types/schemaManagement';

const BASE_URL = '/api/SchemaManagement';

export const schemaManagementApi = {
  // Schema Management
  async getSchemas(): Promise<BusinessSchemaDto[]> {
    const response = await apiClient.get<BusinessSchemaDto[]>(`${BASE_URL}/schemas`);
    return response.data;
  },

  async getSchema(id: string): Promise<BusinessSchemaDto> {
    const response = await apiClient.get<BusinessSchemaDto>(`${BASE_URL}/schemas/${id}`);
    return response.data;
  },

  async createSchema(request: CreateSchemaRequest): Promise<BusinessSchemaDto> {
    const response = await apiClient.post<BusinessSchemaDto>(`${BASE_URL}/schemas`, request);
    return response.data;
  },

  async updateSchema(id: string, request: UpdateSchemaRequest): Promise<BusinessSchemaDto> {
    const response = await apiClient.put<BusinessSchemaDto>(`${BASE_URL}/schemas/${id}`, request);
    return response.data;
  },

  async deleteSchema(id: string): Promise<void> {
    await apiClient.delete(`${BASE_URL}/schemas/${id}`);
  },

  async setDefaultSchema(id: string): Promise<void> {
    await apiClient.post(`${BASE_URL}/schemas/${id}/set-default`);
  },

  // Schema Version Management
  async getSchemaVersions(schemaId: string): Promise<BusinessSchemaVersionDto[]> {
    const response = await apiClient.get<BusinessSchemaVersionDto[]>(`${BASE_URL}/schemas/${schemaId}/versions`);
    return response.data;
  },

  async getSchemaVersion(versionId: string): Promise<BusinessSchemaVersionDto> {
    const response = await apiClient.get<BusinessSchemaVersionDto>(`${BASE_URL}/versions/${versionId}`);
    return response.data;
  },

  async createSchemaVersion(request: CreateSchemaVersionRequest): Promise<BusinessSchemaVersionDto> {
    const response = await apiClient.post<BusinessSchemaVersionDto>(`${BASE_URL}/versions`, request);
    return response.data;
  },

  async setCurrentVersion(versionId: string): Promise<void> {
    await apiClient.post(`${BASE_URL}/versions/${versionId}/set-current`);
  },

  async deleteSchemaVersion(versionId: string): Promise<void> {
    await apiClient.delete(`${BASE_URL}/versions/${versionId}`);
  },

  // Content Management
  async updateTableContext(id: string, request: UpdateTableContextRequest): Promise<SchemaTableContextDto> {
    const response = await apiClient.put<SchemaTableContextDto>(`${BASE_URL}/table-contexts/${id}`, request);
    return response.data;
  },

  async updateColumnContext(id: string, request: UpdateColumnContextRequest): Promise<SchemaColumnContextDto> {
    const response = await apiClient.put<SchemaColumnContextDto>(`${BASE_URL}/column-contexts/${id}`, request);
    return response.data;
  },

  async updateGlossaryTerm(id: string, request: UpdateGlossaryTermRequest): Promise<SchemaGlossaryTermDto> {
    const response = await apiClient.put<SchemaGlossaryTermDto>(`${BASE_URL}/glossary-terms/${id}`, request);
    return response.data;
  },

  async updateRelationship(id: string, request: UpdateRelationshipRequest): Promise<SchemaRelationshipDto> {
    const response = await apiClient.put<SchemaRelationshipDto>(`${BASE_URL}/relationships/${id}`, request);
    return response.data;
  },

  // Apply Auto-Generated Content
  async applyAutoGeneratedContent(request: ApplyAutoGeneratedContentRequest): Promise<BusinessSchemaVersionDto> {
    const response = await apiClient.post<BusinessSchemaVersionDto>(`${BASE_URL}/apply`, request);
    return response.data;
  },

  // User Preferences
  async getUserPreferences(): Promise<UserSchemaPreferenceDto[]> {
    const response = await apiClient.get<UserSchemaPreferenceDto[]>(`${BASE_URL}/user-preferences`);
    return response.data;
  },

  async setDefaultUserSchema(schemaVersionId: string): Promise<void> {
    await apiClient.post(`${BASE_URL}/user-preferences/default/${schemaVersionId}`);
  },

  async getDefaultUserSchema(): Promise<UserSchemaPreferenceDto | null> {
    try {
      const response = await apiClient.get<UserSchemaPreferenceDto>(`${BASE_URL}/user-preferences/default`);
      return response.data;
    } catch (error: any) {
      if (error.response?.status === 404) {
        return null;
      }
      throw error;
    }
  },

  // Schema Comparison
  async compareSchemaVersions(version1Id: string, version2Id: string): Promise<SchemaComparisonResult> {
    const response = await apiClient.get<SchemaComparisonResult>(`${BASE_URL}/compare/${version1Id}/${version2Id}`);
    return response.data;
  },

  // Import/Export
  async exportSchemaVersion(versionId: string): Promise<SchemaExportData> {
    const response = await apiClient.get<SchemaExportData>(`${BASE_URL}/export/${versionId}`);
    return response.data;
  },

  async importSchemaVersion(schemaId: string, request: SchemaImportRequest): Promise<BusinessSchemaVersionDto> {
    const response = await apiClient.post<BusinessSchemaVersionDto>(`${BASE_URL}/import/${schemaId}`, request);
    return response.data;
  },

  // Utility Methods
  async validateSchemaName(name: string, excludeId?: string): Promise<boolean> {
    try {
      const schemas = await this.getSchemas();
      return !schemas.some(s => s.name.toLowerCase() === name.toLowerCase() && s.id !== excludeId);
    } catch (error) {
      console.error('Error validating schema name:', error);
      return false;
    }
  },

  async getSchemaStats(): Promise<{
    totalSchemas: number;
    activeSchemas: number;
    totalVersions: number;
    defaultSchema: BusinessSchemaDto | null;
  }> {
    try {
      const schemas = await this.getSchemas();
      return {
        totalSchemas: schemas.length,
        activeSchemas: schemas.filter(s => s.isActive).length,
        totalVersions: schemas.reduce((sum, s) => sum + s.totalVersions, 0),
        defaultSchema: schemas.find(s => s.isDefault) || null
      };
    } catch (error) {
      console.error('Error getting schema stats:', error);
      return {
        totalSchemas: 0,
        activeSchemas: 0,
        totalVersions: 0,
        defaultSchema: null
      };
    }
  },

  // Search and Filter
  async searchSchemas(query: string): Promise<BusinessSchemaDto[]> {
    try {
      const schemas = await this.getSchemas();
      const lowerQuery = query.toLowerCase();
      return schemas.filter(schema => 
        schema.name.toLowerCase().includes(lowerQuery) ||
        schema.description?.toLowerCase().includes(lowerQuery) ||
        schema.tags.some(tag => tag.toLowerCase().includes(lowerQuery)) ||
        schema.createdBy.toLowerCase().includes(lowerQuery)
      );
    } catch (error) {
      console.error('Error searching schemas:', error);
      return [];
    }
  },

  async searchContent(versionId: string, query: string, contentType?: 'tables' | 'columns' | 'glossary' | 'relationships'): Promise<{
    tables: SchemaTableContextDto[];
    columns: SchemaColumnContextDto[];
    glossary: SchemaGlossaryTermDto[];
    relationships: SchemaRelationshipDto[];
  }> {
    try {
      const version = await this.getSchemaVersion(versionId);
      const lowerQuery = query.toLowerCase();

      const searchTables = (tables: SchemaTableContextDto[]) => 
        tables.filter(table => 
          table.tableName.toLowerCase().includes(lowerQuery) ||
          table.businessPurpose?.toLowerCase().includes(lowerQuery) ||
          table.businessContext?.toLowerCase().includes(lowerQuery) ||
          table.primaryUseCase?.toLowerCase().includes(lowerQuery)
        );

      const searchColumns = (columns: SchemaColumnContextDto[]) =>
        columns.filter(column =>
          column.columnName.toLowerCase().includes(lowerQuery) ||
          column.businessName?.toLowerCase().includes(lowerQuery) ||
          column.businessDescription?.toLowerCase().includes(lowerQuery) ||
          column.businessDataType?.toLowerCase().includes(lowerQuery)
        );

      const searchGlossary = (terms: SchemaGlossaryTermDto[]) =>
        terms.filter(term =>
          term.term.toLowerCase().includes(lowerQuery) ||
          term.definition.toLowerCase().includes(lowerQuery) ||
          term.businessContext?.toLowerCase().includes(lowerQuery) ||
          term.category?.toLowerCase().includes(lowerQuery)
        );

      const searchRelationships = (relationships: SchemaRelationshipDto[]) =>
        relationships.filter(rel =>
          rel.fromTable.toLowerCase().includes(lowerQuery) ||
          rel.toTable.toLowerCase().includes(lowerQuery) ||
          rel.relationshipType.toLowerCase().includes(lowerQuery) ||
          rel.businessDescription?.toLowerCase().includes(lowerQuery)
        );

      return {
        tables: (!contentType || contentType === 'tables') ? searchTables(version.tableContexts || []) : [],
        columns: (!contentType || contentType === 'columns') ? searchColumns(version.columnContexts || []) : [],
        glossary: (!contentType || contentType === 'glossary') ? searchGlossary(version.glossaryTerms || []) : [],
        relationships: (!contentType || contentType === 'relationships') ? searchRelationships(version.relationships || []) : []
      };
    } catch (error) {
      console.error('Error searching content:', error);
      return { tables: [], columns: [], glossary: [], relationships: [] };
    }
  }
};
